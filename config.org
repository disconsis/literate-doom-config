#+TITLE: Literate Doom Config
#+AUTHOR: Ketan Kanishka (ketan.kanishka@nyu.edu)
#+PROPERTY: header-args :results none
#+STARTUP: fold

Enable lexical binding for performance
#+BEGIN_SRC emacs-lisp
;;; -*- lexical-binding: t; -*-
#+END_SRC

* Ideas
Improvement ideas go here.

** Start displaying system information in the modeline if fullscreened
If things like battery information and current date,time were displayed automatically whenever I fullscreened the window (and turned off afterwards) I would probably fullscreen emacs a lot more.

Things that would be nice to be displayed ($\leq$ everything on the bar):
- battery
- date, time
- brightness
- ram, cpu usage

The hard part here is detecting when the frame is fullscreened due to the fact that I'm using a tiling window manager. The information resulting from =(frame-parameter nil 'fullscreen)= is thus not accurate.
** TODO Better key for =+popup/toggle= and friends
** TODO Easier following of compilation buffer, and allow switching to it (maybe with ~, p M~) since it doesn't show up with ~SPC b b~

* Utility functions/packages
Making theme customizations requires duplicating the code in two places: on startup and in =doom-load-theme-hook= (to survive theme changes). A simple utility macro prevents manual duplication.
#+begin_src emacs-lisp
(defmacro modify-theme! (&rest body)
  "Macro which enables theme modifications to persist theme changes.
Runs its body right away and also adds it to `doom-load-theme-hook'."
  `(progn ,@body
          (add-hook! 'doom-load-theme-hook ,@body)))
#+end_src

Apply defaults to a value. Lisp version of Haskell's =fromMaybe=.
#+begin_src emacs-lisp
(defun from-nil (value default)
  (if (null value)
      default
    value))
#+end_src

Delete elements from a sequence in place.
#+begin_src emacs-lisp
(defmacro delete! (elt seq &optional test)
  "Deletes all instances of ELT from SEQ in place. Uses `equal' as TEST by default."
  `(let ((final-test (from-nil ,test #'equal)))
     (require 'dash)
     (setq ,seq (-remove (lambda (item) (funcall final-test ,elt item)) ,seq))))
#+end_src

The =persistent-echo= package uses the echo area to display messages whenever it's free.
#+begin_src emacs-lisp
(use-package! persistent-echo
    :load-path "local/persistent-echo"
    :commands (persistent-echo-mode persistent-echo-enable)
    :defines persistent-echo-display-function)
#+end_src

Evaluate body immediately after a Doom module has loaded. This is useful because Doom modules don't /provide/ a feature which can be directly referred to. Note that this requires the module to be activated for the body to ever evaluate.
Since they don't provide a feature and the directory structure is not completely standardized (some have autoload.el and others have an autoload/ directory) I've resorted to having the file stated explicitly as an argument. This could be improved by getting a list of symbols the body requires, doing a compile-time search for those (could be complicated by metaprogramming), and autoloading on /those/ files.
#+begin_src emacs-lisp
(defmacro after-module! (module &rest body)
  "Execute BODY immediately after the module (CATEGORY MODULE) has loaded."
  (declare (indent defun))
  `(with-eval-after-load (apply #'doom-module-path ',module)
     ,@body))
#+end_src

* Look
** Font
Doom uses a number of font variables for customizing different things.
=doom-font= is the standard font. Since emacs 28, ligatures are composed automatically, so we use a font which has those. Some good options are:
- JetBrains Mono
- Iosevka Term
- Pragmata Pro
- Monoid
- Overpass Mono

There's a few other non-ligature retro fonts which are also nice:
- Victor Mono
- Curie

Some quirky unique fonts:
- Hurmit

#+BEGIN_SRC emacs-lisp
(setq doom-font (font-spec :family "Pragmata Pro" :size 15))
#+END_SRC


Next comes the variable-pitch font. This is mostly used for text-based modes like org.
I use variable-pitch faces in org through =mixed-pitch-mode=, which only applies it to the appropriate faces and makes the others fixed-pitch. So the choice of variable-pitch font must play well with the choice of fixed-pitch (standard) font.
For some reason, setting =doom-variable-pitch-font= first makes =variable-pitch-mode= have no effect (although setting it after =variable-pitch-mode= is enabled and calling =doom/reload-font= makes it take effect). The default font (Verdana) is already really nice, so we'll let this be for now.
I'll list good options anyway for posterity:
- Verdana (the default)
- Aleo
- Helvetica Neue
- ET Book / ET Bembo

NOTE: Earlier, setting =doom-variable-pitch-font= made =variable-pitch-mode= not use it, for some reason. This seems to not be the case anymore, but I have no idea why.

#+begin_src emacs-lisp
(setq doom-variable-pitch-font (font-spec :family "Aleo" :weight 'light))
#+end_src

Other font settings are:
- =doom-unicode-font= which is the fallback font for unicode glyphs
- =doom-unicode-extra-fonts= which is for unicode overrides over the fallback
- =doom-big-font= which is used for presentations with =doom-big-font-mode=
The defaults for all of these are pretty good (the last one defaulting to the default =doom-font=)


*** TODO Add =doom-unicode-font= as fallback

** Theme
=doom-themes= provides a number of excellent themes like:
- doom-one
- doom-tomorrow-night
- doom-dracula
- doom-sourcerer
- doom-nord
- doom-moonlight

Aside from those:
- =tao-yang= is an excellent monochrome light theme, but it's too bright to use in the evenings (insert light-theme joke...)
- tao-yin is a similarly good monochrome dark theme, but needs some configuration
  - by default, it uses sepia instead of grayscale, which doesn't look as good in my opinion
  - you might like for it to customize heights (especially for org-mode), but as of now it sets such an impossibly tiny size for the modeline that it becomes unusable

#+BEGIN_SRC emacs-lisp
(setq doom-theme 'doom-moonlight)
#+END_SRC

We'll make some changes to tao-yin to fix the problems described earlier.
#+begin_src emacs-lisp
(after! tao-theme
  (setq tao-theme-use-sepia nil
        tao-theme-use-height nil))
#+end_src

Another problem with the tao themes is that they assign the same colors to =git-gutter-fr:modified= and =git-gutter-fr:added= (and to =git-gutter:{modified,added}=, but Doom doesn't use those).
We can change them slightly while maintaining the monochrome /a e s t h e t i c/.
#+begin_src emacs-lisp
(after! tao-theme
  (modify-theme!
   (when-let* ((theme (car (-intersection '(tao-yin tao-yang) custom-enabled-themes)))
               (theme-minus-tao (nth 1 (s-split-up-to "-" (symbol-name theme) 1)))
               (palette (intern (concat "tao-theme-" theme-minus-tao "-palette")))
               (color (alist-get "color-15" (funcall palette) nil nil #'string-equal)))
     (set-face-attribute 'git-gutter-fr:added nil :foreground color))))
#+end_src

*** Matching parentheses
=show-smartparens-mode= is responsible for highlighting the matching parenthesis. For most themes this highlight is too subtle to notice. One way to fix this is to draw boxes around the matching parenthesis.
Another way is described by [[https://with-emacs.com/posts/ui-hacks/show-matching-lines-when-parentheses-go-off-screen/][this with-emacs post]] which uses =blink-matching-open= to display an overlay showing the matching open parenthesis. The code /looks/ a little bit messy, which is why I haven't experimented with it yet.

For now, we'll just use =show-smartparens-mode= everywhere.
#+begin_src emacs-lisp
(after! smartparens
  (setq sp-show-pair-delay 0)) ;; no reason to have a delay

(add-hook! '(prog-mode-hook org-mode-hook) #'show-smartparens-mode)
#+end_src

And then let's make the boxes.
#+begin_src emacs-lisp
(after! smartparens
  (modify-theme! (set-face-attribute 'sp-show-pair-match-face nil :box t)))
#+end_src

*** Changing themes
Changing the theme with =counsel-load-theme= has one downside - you can't see the currently active theme.
However, some themes like =solaire-swap-bg-theme= are always loaded (at least in my setup), but these aen't something I want to know about each time I try to change themes. For this we set a list of ignores.
#+begin_src emacs-lisp
(defvar +counsel-load-theme-ignore-prefixes '("solaire-")
  "Prefix of themes to ignore when displaying the current theme with `my/counsel-load-theme-showing-current'.")
#+end_src

We'll make a slight modification to =counsel-load-theme= to display the current theme.
#+begin_src emacs-lisp
(defun +counsel-load-theme ()
  "Minor modification of `counsel-load-theme' to show current theme.
Forward to `load-theme' while showing the currently loaded themes.
Usable with `ivy-resume', `ivy-next-line-and-call' and `ivy-previous-line-and-call'."
  (interactive)
  (let* ((enabled-themes (mapcar #'symbol-name custom-enabled-themes))
         (should-ignore (lambda (theme)
                          (-any-p (lambda (prefix) (s-prefix-p prefix theme)) +counsel-load-theme-ignore-prefixes)))
         (enabled-themes-without-ignores (-remove should-ignore enabled-themes))
         (enabled-theme-string (if enabled-themes-without-ignores
                                   (s-join ", " enabled-themes-without-ignores)
                                 "nil")))
    (ivy-read (format "Load custom theme [current: %s]: " enabled-theme-string)
              (mapcar 'symbol-name
                      (custom-available-themes))
              :action #'counsel-load-theme-action
              :caller 'counsel-load-theme)))
#+end_src

We can change the binding of =counsel-load-theme= to point to our function instead.
NOTE: I wanted to use the =[remap counsel-load-theme]= syntax here to make the keybinding independent of whatever =counsel-load-theme= is actually bound to, but that doesn't work since =counsel-load-theme= is bound by remapping =load-theme=, and [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Remapping-Commands.html][remapped bindings don't propagate through multiple levels]].
NOTE: =:desc= keys seem to only take effect with /prefixes/ (and not /maps/) with =map!=. (=:leader= is an alias for a =:prefix= property.)
#+begin_src emacs-lisp
(map! :leader
      :desc "change theme" "h t" #'+counsel-load-theme)
#+end_src

** Pretty symbols
The prettified symbols for quotes are pretty lackluster. We'll use slightly bigger unicode characters to make them stand out.
#+begin_src emacs-lisp
(when (featurep! :ui pretty-code)
  (plist-put! +pretty-code-symbols :quote "" :quote_end ""))
#+end_src

All modes deserve ligatures!
#+begin_src emacs-lisp
(when (featurep! :ui pretty-code)
  (setq +prog-ligatures-modes t))
#+end_src

** Banner
The startup banner image is customizable, and the default text-based banner could stand to look a little bit better.
[[https://github.com/search?q=setq+%2Bdoom-dashboard-banner-file&type=Code][Searching github for banners]] yielded 4 pages of results - most of them slight variations on the same image. I collected some of the more interesting ones in [[file:banners/][banners/]].
#+begin_src emacs-lisp
(setq +doom-dashboard-banner-dir (expand-file-name "banners" doom-private-dir)
      +doom-dashboard-banner-file "ue.png")
#+end_src

** Startup color
When Doom Emacs starts, there's a blinding flash of white light. Even though it's for a really short time (Doom loads super quick ) it's harsh enough to hurt my eyes, especially at night. We can change the default frame parameters to make the background color dark.
This can be done in two ways:
1. modifying the =default-frame-alist= variable (or related ones)
2. modifying X files (like .Xdefaults)

The first one doesn't quite work if we do it in our main config file (config.el or config.org) since this is loaded /after/ Doom starts, and by then we've already been blinded. I would still like to use elisp for this, even at the cost of a dirty hack, since then we can programmatically make changes (such as setting the startup background color to the one set by =doom-theme=).

The other way is to simply add the following line to .Xdefaults:
#+BEGIN_SRC conf :tangle no
emacs.background: #000000
#+END_SRC

I might end up setting an(other) advice around =counsel-load-theme= which changes this line to use the default background color.

* Workspaces
Since the workspace list disappears so quickly, I often forget about the presence of other workspaces. This detracts from the usefulness of =persp-mode= (or =:ui workspaces=), and I end up destroying the separation of projects.
For now I've resorted to just spamming it in the echo area whenever possible (using the =persistent-echo= package).
*************** TODO Find a less hacky way to keep workspaces displayed
*************** END

We hook the echoing onto the loading of the workspace module. This has the dual benefit of
1. reducing startup time
2. not polluting the echo area till the workspace module is first used

#+begin_src emacs-lisp
(after-module! (:ui workspaces "autoload/workspaces.el")
  ;; Wait a while after a command before displaying the workspaces.
  ;; We can always hit ~SPC TAB TAB~ if in a hurry.
  (setq persistent-echo-delay 5)

  ;; Since workspaces can never *externally*, there's no need to ever refresh.
  (setq persistent-echo-refresh-delay 1000)

  (persistent-echo-enable #'+workspace--tabline))
#+end_src

* Evil
** Leader keys
Like Spacemacs, Doom maps =localleader= to ~SPC m~, but unlike Spacemacs, does not allow accessing it through ~,~
We set its insert-mode counterpart to ~C-,~ , which doesn't do anything important by default.
#+begin_src emacs-lisp
(setq doom-localleader-key ","
      doom-localleader-alt-key "C-,")
#+end_src

Doom sets =leader= to ~SPC~ (which I want) and =leader-alt= (for insert & emacs mode) to ~M-SPC~ (which I don't). ~C-SPC~ works though, and it follows a similar pattern to the localleader bindings.
#+begin_src emacs-lisp
(setq doom-leader-key "SPC"
      doom-leader-alt-key "C-SPC")
#+end_src

** Window commands
By default, windows split to the left and top, which is quite unintuitive (maybe due to English readers' left-to-right bias?)
#+begin_src emacs-lisp
(after! evil
  (setq evil-split-window-below t
        evil-vsplit-window-right t))
#+end_src

Sometimes we want to put a new window in the opposite direction. To do this we would have to split the window, move the cursor to the previous window, and then change the buffer to whatever we want.
Instead, we could use the capitalized versions of the window-split keys to split in the opposite direction.
#+begin_src emacs-lisp
(after! evil
  (defun +evil-window-split-opposite (&optional count file)
    "Split horizontally in the opposite direction as `evil-window-split' would."
    (interactive "P<f>")
    (let ((split-old evil-split-window-below))
      (setq evil-split-window-below (not split-old))
      (ignore-errors ;; to make sure the `evil-split-window-below' is reset
        (evil-window-split count file))
      (setq evil-split-window-below split-old)))

  (defun +evil-window-vsplit-opposite (&optional count file)
    "Split vertically in the opposite direction as `evil-window-vsplit' would."
    (interactive "P<f>")
    (let ((split-old evil-vsplit-window-right))
      (setq evil-vsplit-window-right (not split-old))
      (ignore-errors (evil-window-vsplit count file))
      (setq evil-vsplit-window-right split-old)))

  (map! :leader
        "w S" #'+evil-window-split-opposite
        "w V" #'+evil-window-vsplit-opposite))
#+end_src

I almost always /know/ which evil state I'm in, otherwise a quick ~C-[~ (~ESC~) sets that right. So I don't really care for all the indicators scattered around the UI. The most basic (c.f. ugly) of these is the one in the echo area, so let's at least turn that off.
#+begin_src emacs-lisp
(after! evil
  (setq evil-echo-state nil))
#+end_src

=vim-vinegar= allows a lot of dexterity in quickly jumping around the filesystem, with just a few settings. We'll replicate some of that here.
The most important part is switching to the current directory with a single key press: ~-~
#+begin_src emacs-lisp
(after! dired
  (map! :n "-" #'dired-jump))
#+end_src

The details in =dired= create a lot of visual clutter and it's rarely needed, so we'll turn it off at the start. If required, it's easily accessible through ~(~.
#+begin_src emacs-lisp
(after! dired
  (add-hook 'dired-mode-hook #'dired-hide-details-mode))
#+end_src

Resizing is quite cumbersome in Doom (and also in default Emacs) since you have to repeat the keys over and over again for each increment or decrement. Doom implements a  hydra for this, but it doesn't bind any keys to it for some reason. We'll do that ourselves.
This has a major downside in the fact that windows /flicker/ a lot when using its operations.
#+begin_src emacs-lisp
(map! :when (featurep! :ui hydra)
      :leader
      :n "w ." #'+hydra/window-nav/body)
#+end_src

We can allow window-move commands to wrap around, which is pretty nifty when there are a lot of windows.
This is configured through a variable in the =windmove= package (which =evil= uses).
#+begin_src emacs-lisp
(after! windmove
  (setq windmove-wrap-around t))
#+end_src

** Unimpaired-style keys
I'm quite used to turning search highlights on and off with ~[ h~ and ~] h~. In Doom these move between headings in org-mode, but the same action can also be done with ~C-j~ and ~C-k~, so we can safely remap them.
#+begin_src emacs-lisp
(after! evil
  (defun my/evil-search-hl-on ()
    "Turn on persistent evil search highlights and re-highlight the previous search."
    (interactive)
    (setq evil-ex-search-highlight-all t)
    (save-excursion (evil-ex-search-next)))

  (defun my/evil-search-hl-off ()
    "Turn off persisten evil search highlights and disable any current highlights."
    (interactive)
    (setq evil-ex-search-highlight-all t)
    (evil-ex-nohighlight))

  (map! :n "[ h" #'my/evil-search-hl-off
        :n "] h" #'my/evil-search-hl-on))
#+end_src

Doom sets ~[ e~ and ~] e~ to move between errors. I'm used to using them to /exchange/ lines, so I'll change them. We'll bind keys for errors later.
#+begin_src emacs-lisp
(use-package! move-text
  :after-call (move-text-line-up move-text-line-down)
  :init
  (map! :n "[ e" #'move-text-line-up
        :n "] e" #'move-text-line-down))
#+end_src

* Org-mode
org-mode forms the base of this config, so some quick improvements are sorely needed.

** Blocks
First, some templates are needed to quickly add source blocks.
#+BEGIN_SRC emacs-lisp
(after! org
  (pushnew! org-structure-template-alist
            '("el" . "src emacs-lisp")
            '("hs" . "src haskell")
            '("py" . "src python")
            '("sh" . "src shell")))
#+END_SRC

** Libraries
=org-tempo= needs to be loaded for template expansions like =<el= to work. Inline tasks are also incredibly useful. =org-inlinetask= needs to be loaded for this.
Since these take a decent amount of time to load and are not /immediately/ required, we can defer their loading. We /don't/ need to guard this with an =after! org= block since they're only loaded when emacs is idle.
#+begin_src emacs-lisp
(doom-load-packages-incrementally '(org-tempo org-inlinetask))
#+end_src

** Look
Since org is a text-based mode, it is only natural to use variable-pitch fonts with it. However, source blocks and the like should use fixed-pitch fonts. =mixed-pitch-mode= solves this problem.
We might as well enable this is in all text-based modes. The =mixed-pitch= package resides in the =:ui/zen= module, so that must be enabled for this to work.
#+begin_src emacs-lisp
(when (featurep! :ui zen)
  (add-hook! 'text-mode-hook #'mixed-pitch-mode))
#+end_src

Line numbers also do not make a lot of sense for text-based modes. Doom adds a hook to enable them in text-mode, so we remove that to reduce computation.
#+begin_src emacs-lisp
(remove-hook! 'text-mode-hook #'display-line-numbers-mode)
(add-hook! 'text-mode-hook :append (setq-local display-line-numbers nil))
#+end_src

Emphasis markers clutter up the text, so we turn it off.
#+begin_src emacs-lisp
(after! org
  (setq org-hide-emphasis-markers t))
#+end_src

The default ellipsis looks pretty bad, so add a cool unicode one!
Good options here are:
- ⬎
- 
#+begin_src emacs-lisp
(after! org
  (setq org-ellipsis "  "))
#+end_src

Make the ellipsis the same color as the headline.
#+begin_src emacs-lisp
(after! org
  (modify-theme! (set-face-attribute 'org-ellipsis nil :foreground 'unspecified)))
#+end_src

I like adding empty lines between headlines to keep things neatly organized, but org folds those up along with the block. This prevent this from happening.
#+begin_src emacs-lisp
(after! org
  (setq org-cycle-separator-lines -1))
#+end_src

By default the title uses the normal font and height, just in bold. We can make the font a little prettier and hide a few keywords.
#+begin_src emacs-lisp
(setq +org-title-font "FARRAY")
(setq +org-title-height 3.0)

(after! org
  (pushnew! org-hidden-keywords 'title 'author)
  (modify-theme! (set-face-attribute 'org-document-title nil :family +org-title-font :height +org-title-height)))
#+end_src

When I was using the default variable-pitch font, I spruced up headings by changing the font. Now that I'm using a better font for everything this doesn't seem as neccessary, but I'll leave this code here in case I want to change the heading font again.
#+begin_src emacs-lisp
(defvar +org-heading-font nil
  "Font family to use for org headings.")
(defvar +org-heading-height 1.2
  "Height multiplier to use for org headings")

(after! org
  (modify-theme!
   (when (or +org-heading-font +org-heading-height)
     (dolist (lvl (number-sequence 1 8))
       (let ((face (intern (concat "org-level-" (number-to-string lvl)))))
         (when +org-heading-font (set-face-attribute face nil :family +org-heading-font))
         (when +org-heading-height (set-face-attribute face nil :height +org-heading-height)))))))
#+end_src

The first few default bullets are okay, but the later ones look a bit ugly. The progression of bullets is also not very uniform.
#+begin_src emacs-lisp
(after! org-superstar
  (setq org-superstar-headline-bullets-list '("☰" "☱" "☲" "☳" "☴" "☵" "☶" "☷")))
#+end_src

We can also display bullets as checkmarks for todo headings.
#+begin_src emacs-lisp
(after! org-superstar
  (setq org-superstar-special-todo-items t))
#+end_src

Links being variable pitch screws up the alignment in org-mode tables. A proper fix would probably make the =org-table= face =:extend t=, or use the internals of =mixed-pitch-mode=.
For now, we'll just make links fixed-pitch and save ourselves the trouble.
*************** TODO Extend =org-table= face to make links fixed-pitch _only_ in tables
*************** END
#+begin_src emacs-lisp
(after! mixed-pitch
  (pushnew! mixed-pitch-fixed-pitch-faces 'org-link))
#+end_src

Some themes apply a foreground color to =org-hide=, which sort of defeats the purpose of it - for instance, it makes leading stars somewhat visible even if =org-hide-leading-stars= is set. Due to =solaire-mode= changing the default background for some buffers, we have to set =solaire-org-hide-face= in addition to the standard =org-hide=.
#+begin_src emacs-lisp
(after! org
  (modify-theme!
   (set-face-foreground 'org-hide (face-background 'default))
   (set-face-attribute 'solaire-org-hide-face nil
                       :foreground (face-background 'solaire-default-face))
   ))
#+end_src

Some themes apply an underline to the ellipsis, perhaps in the hopes of making it more visible. This isn't required in our case as we use a special character for =org-ellipsis=, and creates noise.
#+begin_src emacs-lisp
(after! org
  (modify-theme!
   (set-face-underline 'org-ellipsis nil)))
#+end_src

Some themes make the block background extend to the end of the line, some don't; some make the beginning and ending lines same as the block background, some don't. I always prefer the former (in each case), so we'll make this a little bit more consistent by forcing this behaviour.
#+begin_src emacs-lisp
(after! org
  (modify-theme!
   (dolist (face '(org-block org-block-begin-line org-block-end-line))
     (set-face-attribute face nil :background (face-background 'org-block) :extend t))))
#+end_src

** LaTeX
=org-fragtog= allows automatically toggling fragments whenever the cursor is on them.
#+begin_src emacs-lisp
(use-package! org-fragtog
  :hook (org-mode . org-fragtog-mode))
#+end_src

** Checkers
Text-based modes /should/ have both spelling and grammar checks. For technical writing however, I find I spend my time teaching the spell checker more than anything else. A better dictionary than =aspell= is obviously required.
*************** TODO Find a better dictionary for technical writing
*************** END
In the meantime, we'll turn off spell-checking by default.
#+begin_src emacs-lisp
(after! org
  (remove-hook! 'org-mode-hook #'flyspell-mode))
#+end_src

*** TODO add bindings for toggling writegood and langtool

** Notes
Using packages like =org-roam=, =org-noter=, =org-ref=; it's possible to build a good workflow for quickly searching, taking notes, and connecting papers.
[[https://www.reddit.com/r/emacs/comments/gz4lk8/org_brain_and_org_roam/ftf00ky][This comment by u/Cantos]] describes a really nice implementation of this - [[https://github.com/sunnyhasija/DOOMEmacs][dotfiles]]

First of all, set the directory for the notes. I use Dropbox to back them up and possibly access them on mobile.
I know that =org-directory= needs to be set before org loads, and the same is probably also true for =org-roam-directory=; so *don't* put this in an =after!= block.
#+begin_src emacs-lisp
(setq org-directory "~/Dropbox/org")
(setq org-roam-directory (expand-file-name "roam" org-directory))
#+end_src

=org-roam= allows customizing where the titles of a particular file are extracted from. It can optionally use the /first/ heading for this, which seems a bit untuitive to me, so we'll remove that as a source.
#+begin_src emacs-lisp
(after! org-roam
  (setq org-roam-title-sources '(title alias)))
#+end_src

The backlinks buffer is set to the right be default, which takes up a lot of the screen width. Roam research puts it at the bottom, so let's try that out for size. We'll also make this a bit smaller than normal to save more space for the main buffer.
#+begin_src emacs-lisp
(after! org-roam
  (setq org-roam-buffer-position 'bottom)
  (setq org-roam-buffer-height 0.20))
#+end_src

*** Capture templates
The default capture template puts the date in the file name, which just clutters it up. We can fix this by changing the template. We also add prompts for aliases and tags for the file while we're at it.
#+begin_src emacs-lisp
(after! org-roam
  (setq org-roam-capture-templates
        '(("d" "default" plain (function org-roam-capture--get-point)
"#+roam_alias: %^{Aliases}
#+roam_tags:  %^{Tags}

%?"
           :file-name "${slug}"
           :head "#+title: ${title}\n"
           :unnarrowed t))))
#+end_src

*** More interactive graphs
=org-roam-server= provides a /huge/ amount of interactivity for navigating notes - hover preview, tag filtering, clustered nodes which expand on clicking, and more!
#+begin_src emacs-lisp
(use-package! org-roam-server
  :commands org-roam-server-mode)
#+end_src

By default it uses port 8080 for the server. Since it's pretty common to use that port in development and we should be never have to remember it, we'll set it to something more esoteric.
#+begin_src emacs-lisp
(after! org-roam-server
  (setq org-roam-server-port 65529))
#+end_src

=org-roam-server= does not provide any way to automatically browse to the served address, and neither does it start automatically. We'll make both of those things happen. Note that =org-roam-server-mode-hook= is called both when the mode is enabled /and/ when it's disabled, so we have to explicitly check before we browse to its url.
*************** TODO Open this url with a dedicated browser instead of opening it in a new tab
With multiple browsers open it's hard to tell where it'll open. Even if there's just a single one open, it's often dedicated to a particular thing (videos, documentation...) - in which case I don't want org-roam-server to overtake it. This can be solved by dedicating a new browser for it.
Ideally this browser would be lightweight af since it just needs to run some javascript.
*************** END

#+begin_src emacs-lisp
(after! org-roam-server
  (defun my/org-roam-server-browse-to ()
    (interactive)
    (browse-url-xdg-open (format "http://%s:%d" org-roam-server-host org-roam-server-port)))

  (add-hook! 'org-roam-server-mode-hook
    (when org-roam-server-mode (my/org-roam-server-browse-to))))
#+end_src

We'll also replace our keybindings to point to org-roam-server instead of org-roam's default graph command.
#+begin_src emacs-lisp
(map! :leader "n r g" #'org-roam-server-mode)
#+end_src

*** Setting up org-protocol
org-protocol needs to be set up for =org-roam= to capture requests from anywhere in the system (including the org-roam graph).

The following library also needs to be loaded for this to work. This is only sensible for =emacsclient=.
#+begin_src emacs-lisp
(after! server
  (when server-process
    (require 'org-roam-protocol)))
#+end_src

This is accomplished by the following script. Note that the executable needs to be =emacsclient= and not =emacs= since the =org-roam-protocol= library needs to be loaded before this is called.
#+begin_src sh :tangle no
echo "[Desktop Entry]
Name=Org-Protocol
Exec=emacsclient -c %u
Icon=emacs
Type=Application
Terminal=false
MimeType=x-scheme-handler/org-protocol" > ~/.local/share/applications/org-protocol.desktop

xdg-mime default org-protocol.desktop x-scheme-handler/org-protocol
#+end_src

* Spacemacsy keybindings
Make some keybindings a bit more like Spacemacs.
~SPC :~ (=M-x=) in particular is really hard to hit for such a commonly-used command.
#+begin_src emacs-lisp
(map! :leader
      :n "SPC" #'counsel-M-x
      :n ";"   #'pp-eval-expression)
#+end_src

* Checkers & Errors
Vim moves between errors through the "location list", so vim-unimpaired uses ~[ l~ and ~] l~ to move between errors. Since we're using ~[ e~ and ~] e~ to exchange lines, we'll use the same keys for error navigation.
#+begin_src emacs-lisp
(map! :n "[ l" #'previous-error
      :n "] l" #'next-error)
#+end_src

Moving between errors is achieved through ={next,previous}-error=. These sometimes fail where =flycheck-{next,previous}-error= succeeds. I'm not sure why, and I don't want to use the flycheck functions all the time since Doom also uses other sources of errors.
*************** TODO Find the problem and fix it
*************** END


* Quit without confirmation
I almost always end up confirming, so this gets tedious quickly. In any case Doom's quick startup time means I can be back to my session in 2 seconds after quitting. Similarly, I don't really care what processes are running. There's always a few REPLs and shells lying around. After these changes, the only time quitting requires confirmation is when modified buffers exist.
#+begin_src emacs-lisp
(setq confirm-kill-emacs nil
      confirm-kill-processes nil)
#+end_src

* Version control
If I'm trying to commit unstaged changes, I'm usually aware of what I'm doing, but =magit= asks for confirmation each time. Might as well turn this off.
#+begin_src emacs-lisp
(after! magit
  (setq magit-commit-ask-to-stage 'stage))
#+end_src

"Status" sections like "Recent commits" are sometimes collapsed on calling =magit-status=.  It's nice to not have to do that. Stashes are hidden by default, let's keep it that way.
#+begin_src emacs-lisp
(after! magit
  (setq magit-section-initial-visibility-alist '((status . show)
                                                 (stash . hide))))
#+end_src

The =magit-delta= package provides nice syntax-highlighted diffs through the [[https://github.com/dandavison/delta][delta]] pager. =delta= is obviously a requirement here.
#+begin_src emacs-lisp
(use-package! magit-delta
  :after magit
  :config
  ;; from what I can gather, this only needs to be called once
  (magit-delta-mode))
#+end_src

The in-buffer stage and revert commands ask for confirmation, which severely reduces their usability. We can turn this off.
#+begin_src emacs-lisp
(after! git-gutter
  (setq git-gutter:ask-p nil))
#+end_src

** TODO Allow staging and reverting of partial/multiple chunks in-buffer through visual selections
This works in Spacemacs and magit diffs, but not in the buffer of the file itself. It's quite useful, so try to make it work.

** TODO Increase fringe-width in magit buffers to be able to show section collapse indicators

* Language-specific settings
** Shell
Shell programs typically only need to look for documentation through man pages. Anything more complicated than that is probably not going to be searchable through a keyword alone. We set the documentation lookup handler accordingly. Either =man= or =woman= would work here, but since they are interactive commands, when called as lookup handlers they ask the user for input instead of just using the one passed to them. To get around this we wrap them in a lambda.
#+begin_src emacs-lisp
(after! sh-script
  (defun my/woman-non-interactive ;; sexist
      (topic) (woman topic))

  (set-lookup-handlers! 'sh-mode
    :documentation '(my/woman-non-interactive)))
#+end_src

* PDF
=pdf-sync-minor-mode= sometimes hangs on mouse events. I'm usually dealing with PDFs more than TeX files, so we might as well remove it.
#+begin_src emacs-lisp
(after! pdf-tools
  (delete! 'pdf-history-minor-mode pdf-tools-enabled-modes))
#+end_src

I rarely view wide PDFs, so horizontal scrolling is not very useful. Instead, using ~h~ & ~l~ can be used for moving between pages is much more "ergonomic".
#+begin_src emacs-lisp
(after! pdf-tools
  (map! :map pdf-view-mode-map
        :n "h" #'pdf-view-previous-page-command
        :n "l" #'pdf-view-next-page-command))
#+end_src

** Easy highlighting
By default, the workflow for highlighting in a pdf is pretty cumbersome. I wrote a simple package [[file:local/pdf-easy-annot/][pdf-easy-annot]] to highlight text automatically when selected. Note that since this is a local package, it [[https://github.com/hlissner/doom-emacs/issues/1213][shouldn't be put in packages.el]].
#+begin_src emacs-lisp
(use-package! pdf-easy-annot
  :load-path "local/pdf-easy-annot"
  :after pdf-tools
  :config
  (after! pdf-tools
    (map! :map pdf-view-mode-map
          :n "t" #'pdf-easy-annot-hl-minor-mode)))
#+end_src

** TODO mark highlight annotations which have contents for easily figuring out which ones have contents

** TODO display contents through =posframe=

** TODO Recenter pdf on window size changes

** TODO Better keys for "goto page"

** Save pdf on annot change
Auto-save PDFs on any annotation changes. This handles adding, deleting, and editing annotations. I find myelf constantly typing ~:wq~ without this. This should come at the end of this list so that so that if any functions modify the annotation then it's saved later.
#+begin_src emacs-lisp
(after! pdf-tools
  (add-hook! 'pdf-view-mode-hook :append
    (add-to-list 'pdf-annot-modified-functions (cmd! (save-buffer)) t)))
#+end_src

* Filesystem
It's irritating to have to copy and paste a filename from a file just to open it. =find-file-at-point= accomplishes this. Note that this is different from =org-open-at-point=, since I want to follow filenames in strings as well.
#+begin_src emacs-lisp
(map! :map doom-leader-file-map
      "." #'find-file-at-point)
#+end_src

* Shell
** vterm
The default scrollback size of 1000 is really small and takes away the advantages of having a searchable history. We'll turn it waaay up.
#+begin_src emacs-lisp
(after! vterm
  (setq vterm-max-scrollback 50000))
#+end_src

* Force-quit
Sometimes you just hafta gently nudge emacs to commit sudoku with a =kill -9=.
#+begin_src emacs-lisp
(defun +force-kill-emacs ()
  "Force-kill emacs - for when nothing else works."
  (interactive)
  (shell-command (format "kill -9 %s" (emacs-pid))))

(map! :leader "q F" #'+force-kill-emacs)
#+end_src

* Projectile
** Running make
Surprisingly, Doom provides =+make/run= and =+make/run-last= to run make commands in a project (no more switching to the right directory), but does not bind them to any keys. Well, the ~<leader> p~ prefix is right there, and ~m~ isn't bound to anything (atleast right now).
#+begin_src emacs-lisp
(when (featurep! :tools make)
  (map! :leader
        "p m" #'+make/run
        "p M" #'+make/run-last))
#+end_src

