#+TITLE: Literate Doom Config
#+AUTHOR: Ketan Kanishka (ketan.kanishka@nyu.edu)
#+PROPERTY: header-args :results none
#+STARTUP: fold

Enable lexical binding for performance
#+begin_src emacs-lisp
;;; -*- lexical-binding: t; -*-
#+end_src

* Ideas
Improvement ideas go here.

** Start displaying system information in the modeline if fullscreened
If things like battery information and current date,time were displayed automatically whenever I fullscreened the window (and turned off afterwards) I would probably fullscreen emacs a lot more.

Things that would be nice to be displayed ($\leq$ everything on the bar):
- battery
- date, time
- brightness
- ram, cpu usage

The hard part here is detecting when the frame is fullscreened due to the fact that I'm using a tiling window manager. The information resulting from =(frame-parameter nil 'fullscreen)= is thus not accurate.
** TODO Better key for =+popup/toggle= and friends
** TODO Easier following of compilation buffer, and allow switching to it (maybe with ~, p M~) since it doesn't show up with ~SPC b b~
** Remap '-' to act like ~q~ in popup buffers, or at least the help popups
Works like vim-vinegar as in it goes to the previous help (vs directory).
** TODO Add company faces to =mixed-pitch-fixed-pitch-faces=
** TODO Timer to blacklist me from editing config files
Much like pluck.sh, but harder to implement in a non-bypassable way.
Maybe use the remote evaluations to time myself out.
** TODO Capture template to add ideas here
** TODO Stop pdf from moving when editing latex buffers
Is it moving around due to org-noter advices?
It also does that when moving b/w headlines.
** TODO LaTeX: keybind to insert environment in org-mode
Maybe through an org-tempo template.
** TODO pdf-easy-annot: ability to /copy/ the text of a markup annotation
** TODO Fix different bg latex fragments in org-mode
It's caused by the bg of org-block showing up in those places
** TODO pdf: make ~C-o~, ~C-i~ work to swap around the jump list (as in vim, and everywhere else)
** It would be awesome if links would always open up on the same workspace
Opening up a new browser window if neccessary

** TODO Fix ~y s s "~ (and other surrounds) to /not/ put the last surround on the next line
I think this only happens in =visual-line-mode= - it does.
It also screws up ~gcj~.

** TODO pdf-easy-annot-content-marker-minor-mode doesn't work
The ergonomics with pdf-easy-annot-auto-hl-minor-mode are especially bad since you can't activate an annotation while auto-hl is activated
** TODO Turn off evil-mode in vterm
Turn off by default and provide an easy insert-mode toggle (maybe like evil-escape?)

** TODO add hook for auto-revert-mode in dired buffers

** Monospace all-the-icons to maintain alignment in various modes (like all-the-icons-dired)
These issues discuss ways to do this:
- https://github.com/domtronn/all-the-icons.el/issues/82
  - [[https://github.com/domtronn/all-the-icons.el/issues/82#issuecomment-516511749][This code]] works okay last time I tested it, but needs to cache its results
- https://github.com/domtronn/all-the-icons.el/issues/77
  - Using =:height= worked for [[https://github.com/domtronn/all-the-icons.el/issues/77#issuecomment-319219966][this guy]]
  - [[https://github.com/domtronn/all-the-icons.el/issues/77#issuecomment-573872338][This guy]] suggests using the [[https://github.com/cpitclaudel/monospacifier][monospacerify]] tool, which might just work.

** TODO Make company-org-roam completions actually show up

** TODO Set company-complete-...whatever to C-n instead of RET

** TODO pdf-easy-annot: copy text under annotation

** TODO Spacemacs-like "dedicated window" functionality

** TODO Copy find-file-ace-window from scratch buffer

** TODO Remove mail from display-time-mode

** TODO prettify-symbols-mode is not "working" in some areas of the buffer.

** It would be nice to get minimap working - esp. for org-mode files

** Hook the pretty-org-table code from [[https://www.reddit.com/r/emacs/comments/d3a8or/pretty_org_tables_in_the_buffer_chapter_2_it/][reddit]] into something like =org-fragtog=

** TODO Use =custom-theme-set-faces!= instead of (or in addition to) =modify-theme!=
This is because if you modify a theme with =modify-theme!= but later try to change it, the additions made are not removed since they're not part of the theme itself.
This is most evident when using magit with a dark theme /after/ having =doom-flatwhite= enabled for a while.
In the same vein, =doom-darken= and =doom-lighten= can be used for slightly darkening lightening colors.

* Utility functions/packages
Making theme customizations requires duplicating the code in two places: on startup and in =doom-load-theme-hook= (to survive theme changes). A simple utility macro prevents manual duplication.
#+begin_src emacs-lisp
(defmacro modify-theme! (&rest body)
  "Macro which enables theme modifications to persist theme changes.
Runs its body right away and also adds it to `doom-load-theme-hook'."
  `(progn ,@body
          (add-hook! 'doom-load-theme-hook ,@body)))
#+end_src

Apply defaults to a value. Lisp version of Haskell's =fromMaybe=.
#+begin_src emacs-lisp
(defun from-nil (value default)
  (if (null value)
      default
    value))
#+end_src

Delete elements from a sequence in place.
#+begin_src emacs-lisp
(defmacro delete! (elt seq &optional test)
  "Deletes all instances of ELT from SEQ in place. Uses `equal' as TEST by default."
  `(let ((final-test (from-nil ,test #'equal)))
     (require 'dash)
     (setq ,seq (-remove (lambda (item) (funcall final-test ,elt item)) ,seq))))
#+end_src

Evaluate body immediately after a Doom module has loaded. This is useful because Doom modules don't /provide/ a feature which can be directly referred to. Note that this requires the module to be activated for the body to ever evaluate.
Since they don't provide a feature and the directory structure is not completely standardized (some have autoload.el and others have an autoload/ directory) I've resorted to having the file stated explicitly as an argument. This could be improved by getting a list of symbols the body requires, doing a compile-time search for those (could be complicated by metaprogramming), and autoloading on /those/ files.
#+begin_src emacs-lisp
(defmacro after-module! (module &rest body)
  "Execute BODY immediately after the module (CATEGORY MODULE) has loaded."
  (declare (indent defun))
  `(with-eval-after-load (apply #'doom-module-path ',module)
     ,@body))
#+end_src

On a lot of occasions, I want to run a command automatically after saving a buffer. This is generally for checking script output, running tests etc. Doing this by hand (creating a function and adding it to =after-save-hook=) is tedious for these one-off jobs, so we'll write a utility function instead. Note that this should almost always be buffer-local.
#+begin_src emacs-lisp
(defmacro +on-save (body)
  "Run form whenever the current buffer is saved."
  `(add-hook! 'after-save-hook :append :local ,@body))
#+end_src

We still need to write some lisp to make this happen, so it's not accessible in a completely ad-hoc manner yet; but it should allow for more functions which activate on-save handlers in specific modes.


Sometimes I intentionally capture logs to a file *with* ansi escapes, with the intent to view them in color. The following function makes the buffer colored according to the ansi codes.
#+begin_src emacs-lisp
(defun ansify-buffer ()
  (interactive)
  (require 'ansi-color)
  (ansi-color-apply-on-region (point-min) (point-max)))
#+end_src

* Look
** Font
Doom uses a number of font variables for customizing different things.
=doom-font= is the standard font. Since emacs 28, ligatures are composed automatically by Doom, so we use a font which has those. Some good options are:
- JetBrains Mono
- Iosevka Term
- Pragmata Pro
- Monoid
- Overpass Mono
- Victor Mono

There's a few other non-ligature retro fonts which are also nice:
- Curie
- Camingo Code

Some quirky unique fonts:
- Hurmit
- Sudo

#+BEGIN_SRC emacs-lisp
(setq doom-font (font-spec :family "Pragmata Pro" :size 15))
;; (setq doom-font (font-spec :family "Sudo" :size 20))
;; (setq doom-font (font-spec :family "Iosevka Term" :size 15))
;; (setq doom-font (font-spec :family "OverpassMono Nerd Font" :size 15))
;; (setq doom-font (font-spec :family "Camingo Code" :size 15))
;; (setq doom-font (font-spec :family "JetBrains Mono" :size 15))
#+END_SRC

Emacs' font displays start to get really bad for my usual selection of monospace fonts in =doom-big-font-mode=. The only font that looks good (better than its normal-sized version, even) is Victor Mono
#+begin_src emacs-lisp
(setq doom-big-font (font-spec :family "Victor Mono" :size 20))
#+end_src

All variable-pitch fonts looked weird in Emacs. A lot of them had bad kerning or ugly characters at certain sizes. In the end I couldn't find one that consistently looked better than the fixed-pitch font at all sizes, so I'm not using =mixed-pitch-mode=, and by extension, =doom-variable-pitch-font=.

Other font settings are:
- =doom-unicode-font= which is the fallback font for unicode glyphs
- =doom-unicode-extra-fonts= which is for unicode overrides over the fallback
- =doom-big-font= which is used for presentations with =doom-big-font-mode=
The defaults for all of these are pretty good (the last one defaulting to the default =doom-font=)

*** TODO Add =doom-unicode-font= as fallback

** Theme
This is the theme used on startup.
#+begin_src emacs-lisp
(setq doom-theme 'doom-tomorrow-night)
#+end_src

=doom-themes= provides a number of excellent themes like:
- doom-one
- doom-tomorrow-night
- doom-dracula
- doom-sourcerer
- doom-nord
- doom-moonlight
- doom-spacegrey
- doom-flatwhite [light theme]

Aside from those:
- tao-yang is an excellent monochrome light theme, but it's too bright to use in the evenings (insert light-theme joke...)
- tao-yin is a similarly good monochrome dark theme, but needs some configuration
  - by default, it uses sepia instead of grayscale, which doesn't look as good in my opinion

We'll make some changes to tao-yin to fix the problems described earlier.
#+begin_src emacs-lisp
(after! tao-theme
  (setq tao-theme-use-sepia nil
        tao-theme-use-height nil))
#+end_src

Another problem with the tao themes is that they assign the same colors to =git-gutter-fr:modified= and =git-gutter-fr:added= (and to =git-gutter:{modified,added}=, but Doom doesn't use those).
We can change them slightly while maintaining the monochrome /a e s t h e t i c/.
#+begin_src emacs-lisp
(after! tao-theme
  (modify-theme!
   (require 'dash)
   (when-let* ((theme (car (-intersection '(tao-yin tao-yang) custom-enabled-themes)))
               (theme-minus-tao (nth 1 (s-split-up-to "-" (symbol-name theme) 1)))
               (palette (intern (concat "tao-theme-" theme-minus-tao "-palette")))
               (color (alist-get "color-15" (funcall palette) nil nil #'string-equal)))
     (set-face-attribute 'git-gutter-fr:added nil :foreground color))))
#+end_src

The plan9 light theme looks like leuven and being so yellow, is easy on the eyes too. However, for some reason, it decided to set its own font for =org-level-1= and =org-document-title=. The latter is already taken care of by our custom font, but we'll remove the former setting.
#+begin_src emacs-lisp
(modify-theme!
 (when (memq 'plan9 custom-enabled-themes)
   (set-face-attribute 'org-level-1 nil :family 'unspecified)))
#+end_src

kaolin themes are nice, but the modeline border is not.
#+begin_src emacs-lisp
(setq kaolin-themes-modeline-border nil)
#+end_src
They also need to be added to the bg-swap list of =solaire-mode= to make everything look right.
#+begin_src emacs-lisp
(after! solaire-mode (add-to-list 'solaire-mode-themes-to-face-swap "^kaolin-"))
#+end_src

plan9 also makes the modeline also look god-awful.

The doom-flatwhite theme removes any highlighting from branch names in magit, so they tend to blend together with commit messages when viewing the log. We'll add some of the theme's typical background coloring to them to fix this.
#+begin_src emacs-lisp
(after! magit
 (modify-theme!
  (when (memq 'doom-flatwhite custom-enabled-themes)
    (dolist (face '(magit-branch-local
                    magit-branch-current
                    magit-branch-upstream
                    magit-branch-remote
                    magit-branch-remote-head))
      (set-face-attribute face nil
                          :background
                          (face-attribute 'font-lock-string-face :background))))))
#+end_src

Some of the base-16 themes are pretty nifty - e.g. =base16-atelier-savanna= and =base16-atelier-savanna-light=.
Both of these have terrible active modelines and great inactive modelines. This is mostly due to the horrible background color on the active modeline, which is also used for visual selections (and a coupole other places). We'll fix the worst offenders.
We'll also add a subtle background coloring to code blocks in org mode to distinguish them.
*************** TODO Wait for some faces to be loaded before we change them
I want to set some faces, but these might not be loaded yet. However, we also can't just wait for them to be loaded to do this
Right now I just check if they're loaded (with =facep=).
*************** END

#+begin_src emacs-lisp
(modify-theme!
 (require 'dash)
 (when-let* ((theme (car (-intersection '(base16-atelier-savanna base16-atelier-savanna-light)
                                        custom-enabled-themes)))
             (org-block-bg (if (eq theme 'base16-atelier-savanna-light) "#e4ede7" "#1D231F")))

   (set-face-background 'mode-line (face-background 'mode-line-inactive))
   (set-face-background 'secondary-selection (face-background 'hl-line))
   (set-face-background 'region (face-background 'hl-line))
   (when (facep 'company-tooltip-selection) (set-face-background 'company-tooltip-selection "grey80"))
   ;; distinguish org blocks
   (dolist (face '(org-block-begin-line org-block-end-line))
     (when (facep face) (set-face-background face (face-background 'hl-line))))
   (when (facep 'org-block) (set-face-background 'org-block org-block-bg))))
#+end_src


Some =kaolin-themes= customization.
#+begin_src emacs-lisp
(setq kaolin-themes-comments-style 'normal)
#+end_src

=doom-solarized-{light,dark}='s italic comments don't look so good. Disable it for everything.
#+begin_src emacs-lisp
(setq doom-themes-enable-italic nil)
#+end_src

*** Matching parentheses
=show-smartparens-mode= is responsible for highlighting the matching parenthesis. For most themes this highlight is too subtle to notice. One way to fix this is to draw underlines around the matching parenthesis.
Another way is described by [[https://with-emacs.com/posts/ui-hacks/show-matching-lines-when-parentheses-go-off-screen/][this with-emacs post]] which uses =blink-matching-open= to display an overlay showing the matching open parenthesis. The code /looks/ a little bit messy, which is why I haven't experimented with it yet.

For now, we'll just use =show-smartparens-mode= everywhere.
#+begin_src emacs-lisp
(after! smartparens
  (setq sp-show-pair-delay 0)) ;; no reason to have a delay

(add-hook! '(prog-mode-hook org-mode-hook) #'show-smartparens-mode)
#+end_src

And then let's make it underlined.
#+begin_src emacs-lisp
(after! smartparens
  (modify-theme! (set-face-attribute 'sp-show-pair-match-face nil :underline t)))
#+end_src

*** Changing themes
Changing the theme with =counsel-load-theme= has one downside - you can't see the currently active theme.
However, some themes like =solaire-swap-bg-theme= are always loaded (at least in my setup), but these aen't something I want to know about each time I try to change themes. For this we set a list of ignores.
#+begin_src emacs-lisp
(defvar +counsel-load-theme-ignore-prefixes '("solaire-")
  "Prefix of themes to ignore when displaying the current theme with `+counsel-load-theme'.")
#+end_src

We'll make a slight modification to =counsel-load-theme= to display the current theme.
#+begin_src emacs-lisp
(defun +counsel-load-theme ()
  "Minor modification of `counsel-load-theme' to show current theme.
Forward to `load-theme' while showing the currently loaded themes.
Usable with `ivy-resume', `ivy-next-line-and-call' and `ivy-previous-line-and-call'."
  (interactive)
  (let* ((enabled-themes (mapcar #'symbol-name custom-enabled-themes))
         (should-ignore (lambda (theme)
                          (-any-p (lambda (prefix) (s-prefix-p prefix theme)) +counsel-load-theme-ignore-prefixes)))
         (enabled-themes-without-ignores (-remove should-ignore enabled-themes))
         (enabled-theme-string (if enabled-themes-without-ignores
                                   (s-join ", " enabled-themes-without-ignores)
                                 "nil")))
    (ivy-read (format "Load custom theme [current: %s]: " enabled-theme-string)
              (mapcar 'symbol-name
                      (custom-available-themes))
              :action #'counsel-load-theme-action
              :caller 'counsel-load-theme)))
#+end_src

We can change the binding of =counsel-load-theme= to point to our function instead.
NOTE: I wanted to use the =[remap counsel-load-theme]= syntax here to make the keybinding independent of whatever =counsel-load-theme= is actually bound to, but that doesn't work since =counsel-load-theme= is bound by remapping =load-theme=, and [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Remapping-Commands.html][remapped bindings don't propagate through multiple levels]].
NOTE: =:desc= keys seem to only take effect with /prefixes/ (and not /maps/) with =map!=. (=:leader= is an alias for a =:prefix= property.)
#+begin_src emacs-lisp
(map! :leader
      :desc "change theme" "h t" #'+counsel-load-theme)
#+end_src

** Pretty symbols
The prettified symbols for quotes are pretty lackluster. We'll use slightly bigger unicode characters to make them stand out.
#+begin_src emacs-lisp
(when (featurep! :ui ligatures +extra)
  (plist-put! +ligatures-extra-symbols :quote "" :quote_end ""))
#+end_src

And let's do the same for EXAMPLE blocks.
#+begin_src emacs-lisp
(when (featurep! :ui ligatures +extra)
  (plist-put! +ligatures-extra-symbols
              :example ""
              :example_end "<")
  (set-ligatures! 'org-mode
    :example "#+BEGIN_EXAMPLE"
    :example_end "#+END_EXAMPLE"
    :example "#+begin_example"
    :example_end "#+end_example"))
#+end_src

All modes deserve ligatures!
#+begin_src emacs-lisp
(when (featurep! :ui ligatures)
  (setq +ligatures-in-modes t))
#+end_src

Ligatures "extras" are usually distracting in other modes.
#+begin_src emacs-lisp
(when (featurep! :ui ligatures +extra)
  (setq +ligatures-extras-in-modes '(org-mode)))
#+end_src

** Dashboard
Lastly, the doom dashboard “useful commands” are no longer useful to me, and neither is the github link in the footer. For a particularly clean look, disable the modeline and =hl-line-mode=, and also hide the cursor. [taken from [[https://tecosaur.github.io/emacs-config/config.html#splash-screen,code--3][here]]]
#+begin_src emacs-lisp
(remove-hook! '+doom-dashboard-functions #'doom-dashboard-widget-shortmenu #'doom-dashboard-widget-footer)
(add-hook! '+doom-dashboard-mode-hook (hide-mode-line-mode 1) (hl-line-mode -1))
(setq-hook! '+doom-dashboard-mode-hook evil-normal-state-cursor (list nil))
#+end_src

Doom also runs =doom-display-benchmark-h= after init files have loaded. This needs to be done to set the init time, however this has the side effect of printing this in the minibuffer, which I don't like seeing since it's also repeated in the dashboard.
To stop this we have to wrap the call inside a =(let (inhibit-message t) ...)= OR just pass a non-nil value as the optional argument.
#+begin_src emacs-lisp
(remove-hook 'window-setup-hook #'doom-display-benchmark-h)
(add-hook! 'window-setup-hook (doom-display-benchmark-h 'return))
;; (remove-hook! '+doom-dashboard-functions #'doom-dashboard-widget-loaded)
#+end_src

*** Banner
The startup banner image is customizable, and the default text-based banner could stand to look a little bit better.
[[https://github.com/search?q=setq+%2Bdoom-dashboard-banner-file&type=Code][Searching github for banners]] yielded 4 pages of results - most of them slight variations on the same image. I collected some of the more interesting ones in [[file:banners/][banners/]].
#+begin_src emacs-lisp
(setq +doom-dashboard-banner-dir (expand-file-name "banners" doom-private-dir)
      +doom-dashboard-banner-file "e-blue.svg")
#+end_src

** Startup color
When Doom Emacs starts, there's a blinding flash of white light. Even though it's for a really short time (Doom loads super quick ) it's harsh enough to hurt my eyes, especially at night. We can change the default frame parameters to make the background color dark.
This can be done in two ways:
1. modifying the =default-frame-alist= variable (or related ones)
2. modifying X files (like .Xdefaults)

The first one doesn't quite work if we do it in our main config file (config.el or config.org) since this is loaded /after/ Doom starts, and by then we've already been blinded. I would still like to use elisp for this, even at the cost of a dirty hack, since then we can programmatically make changes (such as setting the startup background color to the one set by =doom-theme=).

The other way is to simply add the following line to .Xdefaults:
#+BEGIN_SRC conf :tangle no
emacs.background: #000000
#+END_SRC

I might end up setting an(other) advice around =counsel-load-theme= which changes this line to use the default background color.

** Modeline
The modeline has quite a lot of features I don't need. We'll turn off some of those first.

I find I have no use at all for the size of a buffer.
#+begin_src emacs-lisp
(when (featurep! :ui modeline)
  (remove-hook 'doom-modeline-mode-hook #'size-indication-mode))
#+end_src


Who needs the buffer encoding? This /might/ be useful when the encoding is non-standard, but since it almost /always/ "LF UTF-8" it reduces its utility significantly.
A vim package I used to use had a configurable "blacklist" for buffer encodings which it considered "normal", and wouldn't display. Something like that would make this information worth having on the modeline. As of now, this information isn't important enough for me to write this code.
#+begin_src emacs-lisp
(setq doom-modeline-buffer-encoding nil)
#+end_src


Next, even though we're displaying the perspective (read - "workspace") in the [[*Workspaces][echo area]], it's nice to have it in the modeline too.
#+begin_src emacs-lisp
(setq doom-modeline-persp-name t)
#+end_src

The modeline looks much better to me without any bold or italic faces.
#+begin_src emacs-lisp
(modify-theme!
 (require 's)
 (require 'subr-x)
 (require 'dash)
 (thread-last (face-list)
   (-filter (lambda (face) (s-starts-with? "doom-modeline-" (symbol-name face))))
   (-map (lambda (face)
           (set-face-bold face nil)
           (set-face-italic face nil)))))
#+end_src


I use =display-time-mode= from time-to-time, but only for the clock. By default, it displays mail and system load as well, which I don't want.
#+begin_src emacs-lisp
(setq display-time-mail-file 'none
      display-time-default-load-average nil)
#+end_src

The time format it uses can also look a bit better.
#+begin_src emacs-lisp
(setq display-time-format "%-I:%M %P")
#+end_src

doom-modeline's =no-checker= icon looks a bit ugly. I'd rather not have this at all.
#+begin_src emacs-lisp
(when (featurep! :ui modeline)

  (defun my/remove-no-checker-icon (args)
    (unless (equal args '(no-checker)) args))

  (advice-add #'doom-modeline-update-flycheck-icon
              :filter-args #'my/remove-no-checker-icon))
#+end_src

** Tooltips
Tooltips look a lot cleaner than spamming messages in the echo area, and don't require looking away as much.
This is useful in a variety of unexpected places (like PDFs, for showing annotation contents).
#+begin_src emacs-lisp
(tooltip-mode)
#+end_src

* Evil
** Leader keys
Like Spacemacs, Doom maps =localleader= to ~SPC m~, but unlike Spacemacs, does not allow accessing it through ~,~
We set its insert-mode counterpart to ~C-,~ , which doesn't do anything important by default.
#+begin_src emacs-lisp
(setq doom-localleader-key ","
      doom-localleader-alt-key "C-,")
#+end_src

Doom sets =leader= to ~SPC~ (which I want) and =leader-alt= (for insert & emacs mode) to ~M-SPC~ (which I don't). ~C-SPC~ works though, and it follows a similar pattern to the localleader bindings.
#+begin_src emacs-lisp
(setq doom-leader-key "SPC"
      doom-leader-alt-key "C-SPC")
#+end_src

** Window commands
By default, windows split to the left and top, which is quite unintuitive (maybe due to English readers' left-to-right bias?)
#+begin_src emacs-lisp
(after! evil
  (setq evil-split-window-below t
        evil-vsplit-window-right t))
#+end_src

Sometimes we want to put a new window in the opposite direction. To do this we would have to split the window, move the cursor to the previous window, and then change the buffer to whatever we want.
Instead, we could use the capitalized versions of the window-split keys to split in the opposite direction.
#+begin_src emacs-lisp
(after! evil
  (defun +evil-window-split-opposite (&optional count file)
    "Split horizontally in the opposite direction as `evil-window-split' would."
    (interactive "P<f>")
    (let ((split-old evil-split-window-below))
      (setq evil-split-window-below (not split-old))
      (ignore-errors ;; to make sure the `evil-split-window-below' is reset
        (evil-window-split count file))
      (setq evil-split-window-below split-old)))

  (defun +evil-window-vsplit-opposite (&optional count file)
    "Split vertically in the opposite direction as `evil-window-vsplit' would."
    (interactive "P<f>")
    (let ((split-old evil-vsplit-window-right))
      (setq evil-vsplit-window-right (not split-old))
      (ignore-errors (evil-window-vsplit count file))
      (setq evil-vsplit-window-right split-old)))

  (map! :leader
        "w S" #'+evil-window-split-opposite
        "w V" #'+evil-window-vsplit-opposite))
#+end_src

I almost always /know/ which evil state I'm in, otherwise a quick ~C-[~ (~ESC~) sets that right. So I don't really care for all the indicators scattered around the UI. The most basic (c.f. ugly) of these is the one in the echo area, so let's at least turn that off.
#+begin_src emacs-lisp
(after! evil
  (setq evil-echo-state nil))
#+end_src

=vim-vinegar= allows a lot of dexterity in quickly jumping around the filesystem, with just a few settings. We'll replicate some of that here.
The most important part is switching to the current directory with a single key press: ~-~
#+begin_src emacs-lisp
(after! dired
  (map! :n "-" #'dired-jump))
#+end_src

Resizing is quite cumbersome in Doom (and also in default Emacs) since you have to repeat the keys over and over again for each increment or decrement. Doom implements a  hydra for this, but it doesn't bind any keys to it for some reason. We'll do that ourselves.
This has a major downside in the fact that windows /flicker/ a lot when using its operations.
#+begin_src emacs-lisp
(map! :when (featurep! :ui hydra)
      :leader
      :n "w ." #'+hydra/window-nav/body)
#+end_src

We can allow window-move commands to wrap around, which is pretty nifty when there are a lot of windows.
This is configured through a variable in the =windmove= package (which =evil= uses).
#+begin_src emacs-lisp
(after! windmove
  (setq windmove-wrap-around t))
#+end_src


Doom has two similar functions - =doom/window-enlargen= (bound to ~SPC w o~) and =doom/window-maximize-buffer= (bound to ~SPC w m m~).
The former preserves a little bit of the other windows even as it maximizes the focused one, maybe in a vain attempt to remind the user that they exist. This always seemed ugly to me, and it being bound to a shorter prefix irks me. It's time to set this right. We'll just overwrite the former binding since I never use it anyway.
#+begin_src emacs-lisp
(map! :leader "w o" #'doom/window-maximize-buffer)
#+end_src

** Unimpaired-style keys
I'm quite used to turning search highlights on and off with ~[ h~ and ~] h~. In Doom these move between headings in org-mode, but the same action can also be done with ~C-j~ and ~C-k~, so we can safely remap them.
#+begin_src emacs-lisp
(after! evil
  (defun my/evil-search-hl-on ()
    "Turn on persistent evil search highlights and re-highlight the previous search."
    (interactive)
    (setq evil-ex-search-highlight-all t)
    (save-excursion (evil-ex-search-next)))

  (defun my/evil-search-hl-off ()
    "Turn off persisten evil search highlights and disable any current highlights."
    (interactive)
    (setq evil-ex-search-highlight-all t)
    (evil-ex-nohighlight))

  (map! :n "[ h" #'my/evil-search-hl-off
        :n "] h" #'my/evil-search-hl-on))
#+end_src

Doom sets ~[ e~ and ~] e~ to move between errors. I'm used to using them to /exchange/ lines, so I'll change them. We'll bind keys for errors later.
#+begin_src emacs-lisp
(use-package! move-text
  :after-call (move-text-line-up move-text-line-down)
  :init
  (map! :n "[ e" #'move-text-line-up
        :n "] e" #'move-text-line-down))
#+end_src

** Org-mode keys
=evil-org='s keys for opening lines above/below don't manage list numberings by default.
#+begin_src emacs-lisp
(after! evil-org
  (pushnew! evil-org-special-o/O 'item))
#+end_src

** Surround
=evil-embrace= provides more powerful "surround" commands (like adding/deleting surrounding org blocks).
The show-help popup is immensely irritating though.
#+begin_src emacs-lisp
(after! evil-embrace
  (setq evil-embrace-show-help-p nil))
#+end_src

** Ex commands
Evil provides an option to run substitute commands globally by default, which is almost always what I want.
#+begin_src emacs-lisp
(after! evil
  (setq evil-ex-substitute-global t))
#+end_src

* Org-mode
org-mode forms the base of this config, so some quick improvements are sorely needed.

** Startup
Org-mode provides a plethora of startup options.
One of these that I really enjoy (and is turned off by default) is inline latex previews. One downside of this is that the previews might take some time to build if they're not already built, but they're often important enough for the wait.
#+begin_src emacs-lisp
(after! org
  (setq org-startup-with-latex-preview t))
#+end_src

Similarly, inline images are always welcome, but this starts requesting all the links in the buffer at startup which takes a long-ass time. However, downloading remote images takes a long time, so we never want that at /startup/.
#+begin_src emacs-lisp
(after! org
  (setq org-display-remote-inline-images 'skip)
  (setq org-startup-with-inline-images t))
#+end_src

** Blocks
First, some templates are needed to quickly add source blocks.
#+BEGIN_SRC emacs-lisp
(after! org
  (delete! '("l" . "export latex") org-structure-template-alist)
  (pushnew! org-structure-template-alist
            '("el" . "src emacs-lisp")
            '("hs" . "src haskell")
            '("py" . "src python")
            '("l" . "src latex")
            '("ls" . "src latex")
            '("sh" . "src shell")))
#+END_SRC

The help message at the top is ugly and it's only required because the bindings are inconsistent (sometimes confirmation is ~C-c C-c~ and sometimes it's ~C-c C-'~). The bindings are also inconsistent with the rest of Doom.
A bunch of improvements can be made here, starting with turning off the help message header.
#+begin_src emacs-lisp
(after! org
  (setq org-edit-src-persistent-message nil))
#+end_src

#+begin_src emacs-lisp
(after! org
  (map! :map org-src-mode-map
        :localleader
        "," #'org-edit-src-exit
        "s" #'org-edit-src-save
        "k" #'org-edit-src-abort))
#+end_src

*************** TODO Modify ~:wq~, ~:q~, ~:w~ to call =org-edit-src-exit=, =org-edit-src-abort=, =org-edit-src-save= respectively
   Also consider Spacemacs' ~,,~ , ~,s~, and ~,k~ to confirm, save, and exit.
*************** END

*************** TODO The normal-mode keys don't always work at the start
But the insert-mode (or emacs-mode maybe?) ones always do (~C-, [sk,]~) and the normal-mode ones do after that.
I'm not sure if this is a loading issue, since normal keys revert to being non-functional /again/ when visiting the  buffer again, even when they worked just a moment earlier.
*************** END

It's also irritating that another window pops up whenever we're editing a special block. We can make it open in the same window to preserve the layout.
#+begin_src emacs-lisp
(after! org
  (setq org-src-window-setup 'current-window))
#+end_src


=ob-async= allows asyncrhonous execution of code blocks but does *not* support =:session=, which (to me) is quite a crucial deficiency. =ob-session-async= fixes this.
#+begin_src emacs-lisp
(use-package! ob-session-async)
#+end_src

org-mode tries to indent src blocks by 2, which requires frequent indentation problems. This turns it off.
#+begin_src emacs-lisp
(after! org
  (setq org-edit-src-content-indentation 0))
#+end_src

** Look
Line numbers also do not make a lot of sense for text-based modes. Doom adds a hook to enable them in text-mode, so we remove that to reduce computation.
#+begin_src emacs-lisp
(remove-hook! 'text-mode-hook #'display-line-numbers-mode)
(add-hook! 'text-mode-hook :append (setq-local display-line-numbers nil))
#+end_src

Emphasis markers clutter up the text, so we turn it off.
#+begin_src emacs-lisp
(after! org
  (setq org-hide-emphasis-markers t))
#+end_src

The default ellipsis looks pretty bad, so add a cool unicode one!
Good options here are:
- ⬎
- 
#+begin_src emacs-lisp
(after! org
  (setq org-ellipsis "  "))
#+end_src

Make the ellipsis the same color as the headline.
#+begin_src emacs-lisp
(after! org
  (modify-theme! (set-face-attribute 'org-ellipsis nil :foreground 'unspecified)))
#+end_src

I like adding empty lines between headlines to keep things neatly organized, but org folds those up along with the block. This prevent this from happening.
#+begin_src emacs-lisp
(after! org
  (setq org-cycle-separator-lines -1))
#+end_src

By default the title uses the normal font and height, just in bold. We can make the font a little prettier and hide a few keywords.
#+begin_src emacs-lisp
(setq +org-title-font nil)
(setq +org-title-height 3.0)

(after! org
  (pushnew! org-hidden-keywords 'title 'author)
  (modify-theme!
   (when +org-title-font (set-face-attribute 'org-document-title nil :family +org-title-font))
   (when +org-title-height (set-face-attribute 'org-document-title nil :height +org-title-height))))
#+end_src

When I was using the default variable-pitch font, I spruced up headings by changing the font. Now that I'm using a better font for everything this doesn't seem as neccessary, but I'll leave this code here in case I want to change the heading font again.
#+begin_src emacs-lisp
(defvar +org-heading-font nil
  "Font family to use for org headings.")
(defvar +org-heading-height 1.0
  "Height multiplier to use for org headings")

(after! org
  (modify-theme!
   (when (or +org-heading-font +org-heading-height)
     (dolist (lvl (number-sequence 1 8))
       (let ((face (intern (concat "org-level-" (number-to-string lvl)))))
         (when +org-heading-font (set-face-attribute face nil :family +org-heading-font))
         (when +org-heading-height (set-face-attribute face nil :height +org-heading-height)))))))
#+end_src

The first few default bullets are okay, but the later ones look a bit ugly. The progression of bullets is also not very uniform.
#+begin_src emacs-lisp
(after! org-superstar
  (setq org-superstar-headline-bullets-list '("§")))
#+end_src

We can also display bullets as checkmarks for todo headings.
#+begin_src emacs-lisp
(after! org-superstar
  (setq org-superstar-special-todo-items t))
#+end_src

Links being variable pitch screws up the alignment in org-mode tables. A proper fix would probably make the =org-table= face =:extend t=, or use the internals of =mixed-pitch-mode=.
For now, we'll just make links fixed-pitch and save ourselves the trouble.
*************** TODO Extend =org-table= face to make links fixed-pitch _only_ in tables
*************** END
#+begin_src emacs-lisp
(after! mixed-pitch
  (pushnew! mixed-pitch-fixed-pitch-faces 'org-link))
#+end_src

Some themes apply a foreground color to =org-hide=, which sort of defeats the purpose of it - for instance, it makes leading stars somewhat visible even if =org-hide-leading-stars= is set. Due to =solaire-mode= changing the default background for some buffers, we have to set =solaire-org-hide-face= in addition to the standard =org-hide=.
#+begin_src emacs-lisp
(after! (org solaire-mode)
  (modify-theme!
   (set-face-foreground 'org-hide (face-background 'default))
   (set-face-attribute 'solaire-org-hide-face nil
                       :foreground (face-background 'solaire-default-face))
   ))
#+end_src

Some themes apply an underline to the ellipsis, perhaps in the hopes of making it more visible. This isn't required in our case as we use a special character for =org-ellipsis=, and creates noise.
#+begin_src emacs-lisp
(after! org
  (modify-theme!
   (set-face-underline 'org-ellipsis nil)))
#+end_src

Some themes make the block background extend to the end of the line, some don't; some make the beginning and ending lines same as the block background, some don't. I always prefer the former (in each case), so we'll make this a little bit more consistent by forcing this behaviour.
#+begin_src emacs-lisp
(after! org
  (modify-theme!
   (dolist (face '(org-block org-block-begin-line org-block-end-line org-quote))
     (set-face-attribute face nil :background (face-background 'org-block) :extend t))))
#+end_src

Super and subscripts are nice to have in emacs itself, but I don't want them to escape into exported documents unless I absolutely want them.
#+begin_src emacs-lisp
(after! org
  (setq org-export-with-sub-superscripts '{}))
#+end_src

Headlines in org-mode are first-class, by which I mean that a lot of information is stored only as headlines rather than just having them as content headers.
This means that they should be very readable, and having non-emphasized headlines helps a lot in this regard.
#+begin_src emacs-lisp
(after! org
  (modify-theme!
   (dolist (lvl (number-sequence 1 8))
     (let ((face (intern (concat "org-level-" (number-to-string lvl)))))
       (set-face-bold face nil)))))
#+end_src

In the same vein, other elements also look better without being bolded.
#+begin_src emacs-lisp
(after! org
  (modify-theme!
   (set-face-bold 'org-link nil)))
#+end_src


For consistency's sake, it's useful to make the outshine levels look the same as the org levels, regardless of theme.
#+begin_src emacs-lisp
(after! outshine
  (modify-theme!
   (dolist (lvl (number-sequence 1 8))
     (let ((org-level-face (intern (format "org-level-%d" lvl)))
           (outshine-level-face (intern (format "outshine-level-%d" lvl))))
       (set-face-attribute outshine-level-face nil :inherit org-level-face :underline t)))))
#+end_src

** Libraries
=org-tempo= needs to be loaded for template expansions like =<el= to work. Inline tasks are also incredibly useful. =org-inlinetask= needs to be loaded for this.
Since these take a decent amount of time to load and are not /immediately/ required, we can defer their loading. We /don't/ need to guard this with an =after! org= block since they're only loaded when emacs is idle.
#+begin_src emacs-lisp
(doom-load-packages-incrementally '(org-tempo org-inlinetask))
#+end_src

Turns out that the syntax highlighting of inline tasks is borked (wrong indentation with =org-indent-mode=, wrong highlighting according to level, content below the "END" heading is indented) if =org-inlinetask= is not loaded. This is irritating enough that I'll take the load time. We'll keep the incremental loading in case an org buffer isn't needed right away.
*************** TODO Since =org-mode-hook= is run *after* the mode has been activated, =org-inlinetask= sometimes loads after the buffer loads org-mode, which screws up the syntax of inline tasks.
I always end up reloading org-mode in this case - maybe this could happen automatically.
This is what I've tried below. See if it works.
*NO IT DOESN'T.
**************** END

#+begin_src emacs-lisp
;; (after! org
;;   (add-hook! 'org-mode-hook (unless (featurep 'org-inlinetask)
;;                                 (require 'org-inlinetask)
;;                                 (org-mode-restart))))
#+end_src

** LaTeX
=org-fragtog= allows automatically toggling fragments whenever the cursor is on them.
#+begin_src emacs-lisp
(use-package! org-fragtog
  :hook (org-mode . org-fragtog-mode))
#+end_src

By default, latex snippets are not highlighted unless put in a (src/export/latex) block; however putting them in a block prevents them being previewed (through =org-latex-preview=). The solution is to set the following variable.
#+begin_src emacs-lisp
(after! org
  (setq org-highlight-latex-and-related '(native)))
#+end_src

** Checkers
Text-based modes /should/ have both spelling and grammar checks. For technical writing however, I find I spend my time teaching the spell checker more than anything else. A better dictionary than =aspell= is obviously required.
*************** TODO Find a better dictionary for technical writing
*************** END
In the meantime, we'll turn off spell-checking by default.
#+begin_src emacs-lisp
(after! org
  (remove-hook! 'org-mode-hook #'flyspell-mode))
#+end_src

*** TODO add bindings for toggling writegood and langtool

*** TODO stop remote evaluation of code blocks

** Notes
Using packages like =org-roam=, =org-noter=, =org-ref=; it's possible to build a good workflow for quickly searching, taking notes, and connecting papers.
[[https://www.reddit.com/r/emacs/comments/gz4lk8/org_brain_and_org_roam/ftf00ky][This comment by u/Cantos]] describes a really nice implementation of this - [[https://github.com/sunnyhasija/DOOMEmacs][dotfiles]]

First of all, set the directory for the notes. I use Dropbox to back them up and possibly access them on mobile.
I know that =org-directory= needs to be set before org loads, and the same is probably also true for =org-roam-directory=; so *don't* put this in an =after!= block.
#+begin_src emacs-lisp
(setq org-directory "~/Dropbox/org")
(setq org-roam-directory (expand-file-name "roam" org-directory))
#+end_src

=org-roam= allows customizing where the titles of a particular file are extracted from. It can optionally use the /first/ heading for this, which seems a bit untuitive to me, so we'll remove that as a source.
#+begin_src emacs-lisp
(after! org-roam
  (setq org-roam-title-sources '(title alias)))
#+end_src

The backlinks buffer is set to the right be default, which takes up a lot of the screen width. Roam research puts it at the bottom, so let's try that out for size. We'll also make this a bit smaller than normal to save more space for the main buffer.
#+begin_src emacs-lisp
(after! org-roam
  (setq org-roam-buffer-position 'bottom)
  (setq org-roam-buffer-height 0.20))
#+end_src

*** Capture templates
The default capture template puts the date in the file name, which just clutters it up. We can fix this by changing the template. We also add prompts for aliases and tags for the file while we're at it.
#+begin_src emacs-lisp
(after! org-roam
  (setq org-roam-capture-templates
        '(("d" "default" plain (function org-roam-capture--get-point)
"#+roam_alias: %^{Aliases}
#+roam_tags:  %^{Tags}

%?"
           :file-name "${slug}"
           :head "#+title: ${title}\n"
           :unnarrowed t))))
#+end_src

*** More interactive graphs
=org-roam-server= provides a /huge/ amount of interactivity for navigating notes - hover preview, tag filtering, clustered nodes which expand on clicking, and more!
#+begin_src emacs-lisp
(use-package! org-roam-server
  :commands org-roam-server-mode)
#+end_src

By default it uses port 8080 for the server. Since it's pretty common to use that port in development and we should be never have to remember it, we'll set it to something more esoteric.
#+begin_src emacs-lisp
(after! org-roam-server
  (setq org-roam-server-port 65529))
#+end_src

We set a browser to use which will open up org-roam-server's page. Characteristics that it should have:
- should open up a /new/ window instead of a tab, since it's not predictable which browser that will show up in (in case of multiple browsers)
- as lightweight as possible, since it just has to run some javascript
- should use the desktop file we've set up when opening =org-protocol://= links

I considered a number of browsers for this:
| browser | renders correctly? | handles org-protocol? | lightweight?                          | comments                                                       |
|---------+--------------------+-----------------------+---------------------------------------+----------------------------------------------------------------|
| [[https://www.mozilla.org][firefox]] | yes                | yes                   | lol no                                |                                                                |
| [[https://surf.suckless.org][surf]]    | yes                | no                    | poster child for lightweight browsers | kept prepending =http://= to the org-protocol links              |
| [[https://www.dillo.org][dillo]]   | no                 | ?                     | yes                                   | the UI looks god awful                                         |
| [[https://astian.org/midori/about/][midori]]  | yes                | yes                   | yes                                   | detaches from the terminal & all tabs run in the same process, |
|         |                    |                       |                                       | so the process cannot be killed cleanly                        |

Out of these midori fulfilled all my criteria, but I haven't had enough time with it to verify the "lightweight" claim.

#+begin_src emacs-lisp
(defvar +org-roam-server-browser-program '("midori" "-a")
  "Browser program (and its arguments) to use to view `org-roam-server' page.")
#+end_src

=org-roam-server= does not provide any way to automatically browse to the served address, and neither does it start automatically. We'll  make both of those things happen. Note that =org-roam-server-mode-hook= is called both when the mode is enabled /and/ when it's disabled, so we have to explicitly check before we browse to its url.
#+begin_src emacs-lisp
(after! org-roam-server
  (defvar +org-roam-server-browser-process nil
    "Browser process open at org-roam-server's address.")

  (defun +org-roam-server-start-browser ()
    (unless (and +org-roam-server-browser-process
                 (process-live-p +org-roam-server-browser-process))
      (setq +org-roam-server-browser-process
            (apply #'start-process "org-roam-server-browser" nil
                   `(,@+org-roam-server-browser-program
                     ,(format "http://%s:%d" org-roam-server-host org-roam-server-port)))
            )))

  (defun +org-roam-server-stop-browser ()
    (when (and +org-roam-server-browser-process
               (process-live-p +org-roam-server-browser-process))
      (stop-process +org-roam-server-browser-process)))

  (add-hook! 'org-roam-server-mode-hook
    (if org-roam-server-mode
        (+org-roam-server-start-browser)
      (+org-roam-server-stop-browser))))
#+end_src

We'll also replace our keybindings to point to org-roam-server instead of org-roam's default graph command.
#+begin_src emacs-lisp
(map! :leader "n r g" #'org-roam-server-mode)
#+end_src

The physics simulation has some room for improvement, especially in the repulsion department.
#+begin_src emacs-lisp
(after! org-roam-server
  (setq org-roam-server-network-vis-options
        (json-encode-plist
         '(:physics (:solver forceAtlas2Based            ;; better repulsion
                     :forceAtlas2Based (:avoidOverlap 1  ;; try to never overlap
                                        :damping 0.99)   ;; maintain velocity from previous iteration
                     :stabilization (:iterations 500000) ;; keep the simulation going
                     :timestep 0.4                       ;; longer and smoother simulation
                     :minVelocity 0.001)))))             ;; never stop never stopping
#+end_src

**** TODO Make org-protocol link open up in same emacs from which the server was started
Open it in the same *frame* as well.

**** TODO Try using =eaf= to replicate =obr-viz= for =org-roam=
=obr-viz= uses =eaf= to do this *inside* emacs, which is really cool. Try to do something similar for =org-roam=.
I should also probably change the browser to use =eaf= anyway.
Note: EAF's browser uses up almost *100%* of the CPU. Don't try this until/unless you find a fix for that.

**** TODO When trying to start the server, change port automatically if the previous one is bound
Or just kill the previous server, who cares.

*** Setting up org-protocol
org-protocol needs to be set up for =org-roam= to capture requests from anywhere in the system (including the org-roam graph).

The following library also needs to be loaded for this to work. This is only sensible for =emacsclient=.
#+begin_src emacs-lisp
(after! server
  (when server-process
    (require 'org-roam-protocol)))
#+end_src

This is accomplished by the following script. Note that the executable needs to be =emacsclient= and not =emacs= since the =org-roam-protocol= library needs to be loaded before this is called.
#+begin_src sh :tangle no
echo "[Desktop Entry]
Name=Org-Protocol
Exec=emacsclient -c %u
Icon=emacs
Type=Application
Terminal=false
MimeType=x-scheme-handler/org-protocol" > ~/.local/share/applications/org-protocol.desktop

xdg-mime default org-protocol.desktop x-scheme-handler/org-protocol
#+end_src

*** Navigating through tags
org-roam currently does not provide a great mechanism for traversing through tags. It allows /searching/ through them through the =ivy= (or whatever you use for =completing-read=) interface, but once you're one a file with a particular tag you can't just click on something (or press a button) to go to find other pages which share that tag. This is somewhat surprising since the author's demos show tags being specially highlighted (with a prefixed $\S$ and a different color). Looking at the video some more I discovered that /all/ file links were displayed in the same manner, so the "tags" must have just been a list of file links.

[[https://d33wubrfki0l68.cloudfront.net/caf00e01f2762110365beb820f757ccfe15e50df/5facd/ox-hugo/org-roam-buffer.gif][demo]]

Even so, not having this functionality defeats the entire purpose of having tags (imo).

# However, although Roam treats tags and files differently, the author's demo doesn't seem to do the same. In the video, he uses  a keybinding while on a tag to go to the org-roam /file/ linked that tag. (This is perhaps not that surprising, since org-mode doesn't have any mechanism to show tags separately, and even if it did it, the information would be read-only.) Looking through the documentation I could not find the particular command he used for this.

*** TODO Easier keys for org-roam actions when in org-roam buffer

** Agenda
I want to put TODOs in my org-roam files as well, which I have in subdirectory under =org-directory=.
Doom sets =org-agenda-files= to =`(,org-directory)=, but org doesn't recurse into it for finding agenda files.
A simple solution is to just do this manually.
#+begin_src emacs-lisp
(after! org
  (setq org-agenda-files (directory-files-recursively org-directory org-agenda-file-regexp)))
#+end_src

** Editing
*** Invisible text
It's hella hard to handle invisible text like links, emphasised text etc. Here are some improvements to make this easier.

While link urls can be deleted even when they are invisible (through Doom's =+org/remove-link=), they cannot be copied. This can be remedied by modifying =+org/remove-link='s source slightly to produce:
#+begin_src emacs-lisp
(after! org
  (defun +evil-org/copy-link ()
    "Yank link url at point."
    (interactive)
    (unless (org-in-regexp org-link-bracket-re 1)
      (user-error "No link at point"))
    (evil-yank (match-beginning 1) (match-end 1))
    (message "Yanked: %s"
             (let ((str (current-kill 0)))
               (set-text-properties 0 (length str) nil str)
               str)))

  (map! :map org-mode-map
        :localleader "l y" #'+evil-org/copy-link))
#+end_src

*** Beamer
A frame level of 2 is almost always the right choice. I would rather not put this in every file (although that would make it consistent when exporting through any emacs configuration...hmm).
#+begin_src emacs-lisp
(after! org
  (setq org-beamer-frame-level 2))
#+end_src

[[https://github.com/matze/mtheme][Metropolis]] is a /great/ beamer theme.
#+begin_src emacs-lisp
(after! org
  (setq org-beamer-theme "metropolis"))
#+end_src

** TODO Consider using =abbrev-mode= (or =dabbrev-mode=?) to turn "->" into either =->= or $\rightarrow$

** TODO Consider installing =org-sidebar=

** PDF exporting using =minted=
#+begin_src emacs-lisp
(after! org
  (setq org-latex-listings 'minted
        org-latex-packages-alist '(("" "minted"))
        org-latex-pdf-process
        '("pdflatex -shell-escape -interaction nonstopmode -output-directory %o %f"
          "pdflatex -shell-escape -interaction nonstopmode -output-directory %o %f")))
#+end_src

* Spacemacsy keybindings
Make some keybindings a bit more like Spacemacs.
~SPC :~ (=M-x=) in particular is really hard to hit for such a commonly-used command.
#+begin_src emacs-lisp
(map! :leader
      :n "SPC" #'counsel-M-x
      :n ":"   #'pp-eval-expression
      :n ";"   #'pp-eval-expression)
#+end_src

* Checkers & Errors
Vim moves between errors through the "location list", so vim-unimpaired uses ~[ l~ and ~] l~ to move between errors. Since we're using ~[ e~ and ~] e~ to exchange lines, we'll use the same keys for error navigation.
#+begin_src emacs-lisp
(let* ((prefix (if (featurep! :checkers syntax) "flycheck-" ""))
       (previous-error-fn (intern (concat prefix "previous-error")))
       (next-error-fn (intern (concat prefix "next-error"))))
  (map! :n "[ l" previous-error-fn
        :n "] l" next-error-fn))
#+end_src

Moving between errors is achieved through ={next,previous}-error=. These sometimes fail where =flycheck-{next,previous}-error= succeeds. I'm not sure why, and I don't want to use the flycheck functions all the time since Doom also uses other sources of errors.
*************** TODO Find the problem and fix it
*************** END

* Quit without confirmation
I almost always end up confirming, so this gets tedious quickly. In any case Doom's quick startup time means I can be back to my session in 2 seconds after quitting. Similarly, I don't really care what processes are running. There's always a few REPLs and shells lying around. After these changes, the only time quitting requires confirmation is when modified buffers exist.
#+begin_src emacs-lisp
(setq confirm-kill-emacs nil
      confirm-kill-processes nil)
#+end_src

* Version control
If I'm trying to commit unstaged changes, I'm usually aware of what I'm doing, but =magit= asks for confirmation each time. Might as well turn this off.
#+begin_src emacs-lisp
(after! magit
  (setq magit-commit-ask-to-stage 'stage))
#+end_src

"Status" sections like "Recent commits" are sometimes collapsed on calling =magit-status=.  It's nice to not have to do that. Stashes are hidden by default, let's keep it that way.
#+begin_src emacs-lisp
(after! magit
  (setq magit-section-initial-visibility-alist '((status . show)
                                                 (stash . hide))))
#+end_src

The =magit-delta= package provides nice syntax-highlighted diffs through the [[https://github.com/dandavison/delta][delta]] pager. =delta= is obviously a requirement here.
While this looks okay with light themes, it's pretty ugly with dark ones. This is mostly because of the dark diff background color. We'll make this slightly better by making both light and dark themes be the same.
#+begin_src emacs-lisp
(use-package! magit-delta
  :after magit
  :config
  (setq magit-delta-default-dark-theme magit-delta-default-light-theme)
  ;; from what I can gather, this only needs to be called once
  (magit-delta-mode))
#+end_src

The in-buffer stage and revert commands ask for confirmation, which severely reduces their usability. We can turn this off.
#+begin_src emacs-lisp
(after! git-gutter
  (setq git-gutter:ask-p nil))
#+end_src

** TODO Allow staging and reverting of partial/multiple chunks in-buffer through visual selections
This works in Spacemacs and magit diffs, but not in the buffer of the file itself. It's quite useful, so try to make it work.
Turns out Spacemacs uses =git-gutter+= (Doom uses =git-gutter=), and the commands =git-gutter+-stage-hunks= and =git-gutter+-revert-hunks= are resonsible for this behaviour.

** TODO Increase fringe-width in magit buffers to be able to show section collapse indicators

* General coding niceties
Indent guides are kinda useless if they don't highlight the currently active indent guide.
The "normal" setting is ='top=, which highlights just the current indent, but there's another setting ='stack= which highlights a lot more - might come in handy some day.
#+begin_src emacs-lisp
(after! highlight-indent-guides
  (setq highlight-indent-guides-responsive 'top))
#+end_src

I use =outshine-mode= in so many projects, it's best to just enable it everywhere.
=outshine-mode= syntax (=-- * heading=) creates some problems with the haskell formatter =ormolu=
#+begin_src emacs-lisp
(defun my/fix-outshine-haskell ()
  (when (eq major-mode 'haskell-mode)
    (setq-local outshine-regexp-base-char "="))
  (outshine-mode))

(add-hook! 'prog-mode-hook #'my/fix-outshine-haskell)
#+end_src

* Language-specific settings
** Programming languages (general)
The "pretty" symbols in the =:ui pretty-code= module border are really unintuitive. Look at some of these specimens:
#+BEGIN_EXAMPLE
:return        "⟼"
:yield         "⟻"
:map           "↦"
#+END_EXAMPLE

There's others which make slightly more sense, but would be better off not being there.
Instead of turning off  these symbols for each programming language, it's easier to just prune this list of symbols I'll /never/ need.
#+begin_src emacs-lisp
(when (featurep! :ui pretty-code)
 (setq +pretty-code-symbols
       (doom-plist-delete +pretty-code-symbols
                          :return :yield :tuple :pipe :def :map :for
                          :null :true :false :int :float :str :bool ;; types
                          )))
#+end_src

** Shell
Shell programs typically only need to look for documentation through man pages. Anything more complicated than that is probably not going to be searchable through a keyword alone. We set the documentation lookup handler accordingly. Either =man= or =woman= would work here, but since they are interactive commands, when called as lookup handlers they ask the user for input instead of just using the one passed to them. To get around this we wrap them in a lambda.
#+begin_src emacs-lisp
(after! sh-script
  (defun my/woman-non-interactive ;; sexist
      (topic) (woman topic))

  (set-lookup-handlers! 'sh-mode
    :documentation '(my/woman-non-interactive)))
#+end_src

** Python
*** Pretty symbols
Python is already pretty readable, and the custom "pretty" symbols don't really help in its case.
The "prettified" symbols for python are set by the default python progmode.
#+begin_src emacs-lisp
(when (featurep! :lang python)
  (setq python-prettify-symbols-alist nil))
#+end_src

*** Django
# Coding with Django effectively needs a lot of terminal commands, and more importantly, syntax highlighting for the templates.
# #+begin_src emacs-lisp
# (use-package! django-mode
#   :after-call django-mode)
# #+end_src

*** pyls
#+begin_src emacs-lisp
(when (featurep! :lang python +lsp)
  (setq lsp-pyls-plugins-pycodestyle-max-line-length 120))
#+end_src
** z3
=z3-mode= provides some basic interaction with =z3=, but it's really barebones.
#+begin_src emacs-lisp
(use-package! z3-mode
  :config
  ;; (defun +z3/enable-run-on-save ()
  ;;   (interactive)
  ;;   (+on-save (z3-execute-region)))

  (map! :map z3-mode-map
        :localleader
        :nv "," #'z3-execute-region))
#+end_src

** Haskell
Literate haskell should focus on the comments rather than the code. As such, the "comment" face should not be dimmed, but should show up as the default.
#+begin_src emacs-lisp
(modify-theme!
 (set-face-attribute 'haskell-literate-comment-face nil :inherit 'default))
#+end_src

The =\begin{code}= and =\end{code}='s are kinda distracting. Make them like the org mode ligatures.
NOTE: this doesn't work yet.
#+begin_src emacs-lisp
(when (featurep! :ui ligatures +extra)
  (set-ligatures! 'haskell-literate-mode
    :src_block "\\begin{code}"
    :src_block_end "\\end{code}"))
#+end_src

Almost all the formatters for haskell I could find were lacking in some respect - =ormolu= was the best amongst them.
#+begin_src emacs-lisp
(when (featurep! :editor format)
  (after! haskell
    (defun format-all--resolve-system (x) (car x))
    (define-format-all-formatter ormolu
      (:executable "ormolu")
      (:install "stack install ormolu")
      (:modes haskell-mode literate-haskell-mode)
      (:format (format-all--buffer-easy executable)))))
#+end_src

*** TODO Start =ghcid= automatically in a separate pane
Make sure it starts in =insert= or =emacs= mode

** YAML
Since indentation is so important, =mixed-pitch-mode= creates trouble.
#+begin_src emacs-lisp
(when (featurep! :ui zen)
 (add-hook! yaml-mode (mixed-pitch-mode -1)))
#+end_src

** Dart
I'm not sold on the closing labels yet. They just seem to clutter up the code, esp. since the "tree" (or "outline"?) indicators already do most of their job.
#+begin_src emacs-lisp
(after! dart-mode
  (setq lsp-dart-closing-labels nil))
#+end_src

** Elixir
Elixir's LSP implementation has to be installed separately, and unfortunately the AUR package (=elixir-ls=) doesn't put it on the path.
I don't want to pollute my =$PATH= with yet /another/ thing, so we'll add it to just Emacs's =exec-path=, which is the only place it's actually required.
#+begin_src emacs-lisp
(when (featurep! :lang elixir +lsp)
  (after! elixir-mode
    (add-to-list 'exec-path "/usr/lib/elixir-ls/")))
#+end_src

The usual folding modes don't work  too well with Elixir. Yafolding seems to work though.
#+begin_src emacs-lisp
(after! elixir-mode
  (add-hook 'elixir-mode-hook #'yafolding-mode))
#+end_src
** Lua
Set up =lua-language-server= downloaded from AUR.
#+begin_src emacs-lisp
(setq lsp-clients-lua-language-server-bin "/usr/bin/lua-language-server")
(setq lsp-clients-lua-language-server-install-dir "/usr/share/lua-language-server")
(setq lsp-clients-lua-language-server-main-location "/usr/share/lua-language-server/main.lua")
(setq lsp-clients-lua-language-server-command
      '("/usr/bin/lua-language-server" "-E" "/usr/share/lua-language-server/main.lua"))
#+end_src

* PDF
=pdf-sync-minor-mode= sometimes hangs on mouse events. I'm usually dealing with PDFs more than TeX files, so we might as well remove it.
#+begin_src emacs-lisp
(after! pdf-tools
  (delete! 'pdf-sync-minor-mode pdf-tools-enabled-modes))
#+end_src

I rarely view wide PDFs, so horizontal scrolling is not very useful. Instead, using ~h~ & ~l~ can be used for moving between pages is much more "ergonomic". However, they must be told to go to the next/previous page's top in the cases where the whole page is not visible at once, since otherwise they maintain the viewing height as in the current page (which is never what you want).
#+begin_src emacs-lisp
(after! pdf-tools
  (defmacro +pdf--if-page-change (action if-changed)
    "Run the form ACTION, then run the form IF-CHANGED
if the page number has changed."
    `(let ((curr-page (pdf-view-current-page)))
       ,action
       (unless (equal (pdf-view-current-page) curr-page)
         ,if-changed)))

  (defun +pdf-view-next-page-top ()
    "View the top of the next page."
    (interactive)
    (+pdf--if-page-change (pdf-view-next-page-command) (image-bob)))

  (defun +pdf-view-previous-page-top ()
    "View the top of the previous page."
    (interactive)
    (+pdf--if-page-change (pdf-view-previous-page-command) (image-bob)))

  (map! :map pdf-view-mode-map
        :n "h" #'+pdf-view-previous-page-top
        :n "l" #'+pdf-view-next-page-top))
#+end_src

Some annotation workflows are pretty cumbersome in bare pdf-tools. I wrote a package ([[file:local/pdf-easy-annot/][pdf-easy-annot]]) to address some of them. It's in its initial stages at the moment, so I'm developing it locally. I might extract it from here and make it its own thing if it grows large enough.
Right now it provides:
- auto-highlight on selection
- auto-mark markup annotations which have contents (with a squiggly)
#+begin_src emacs-lisp
(use-package! pdf-easy-annot
  :load-path "local/pdf-easy-annot"
  :hook (pdf-view-mode . pdf-easy-annot-auto-hl-minor-mode)
  :hook (pdf-view-mode . pdf-easy-annot-content-markers-minor-mode)
  :config
  (after! pdf-tools
    (map! :map pdf-view-mode-map
          :ne "t" #'pdf-easy-annot-auto-hl-minor-mode ;; for quick toggling
          (:prefix ("e" . "pdf-easy-annot")
           :desc "toggle auto highlighting" :ne "h" #'pdf-easy-annot-auto-hl-minor-mode
           :desc "toggle content markers" :ne "m" #'pdf-easy-annot-content-markers-minor-mode))
    ))
#+end_src

=+= and = can be used to zoom in, but =-= can't be used to zoom out as it's overwritten by evil behaviour (sometimes). Let's just make sure everything works as expected.
#+begin_src emacs-lisp
(after! pdf-tools
  (map! :map pdf-view-mode-map
        "-" #'pdf-view-shrink
        "=" #'pdf-view-enlarge
        "+" #'pdf-view-enlarge))
#+end_src

** TODO Format annotation contents using org syntax, previewing latex fragments

** TODO Recenter pdf on window size changes

** TODO Better keys for "goto page"

** Save pdf on annot change
Auto-save PDFs on any annotation changes. This handles adding, deleting, and editing annotations. I find myelf constantly typing ~:wq~ without this. This should come at the end of this list so that so that if any functions modify the annotation then it's saved later.
#+begin_src emacs-lisp
(after! pdf-tools
  (add-hook! 'pdf-view-mode-hook :append
    (add-to-list 'pdf-annot-modified-functions (cmd! (save-buffer)) t)))
#+end_src

* Filesystem
It's irritating to have to copy and paste a filename from a file just to open it. =find-file-at-point= accomplishes this. Note that this is different from =org-open-at-point=, since I want to follow filenames in strings as well.
#+begin_src emacs-lisp
(map! :map doom-leader-file-map
      "." #'find-file-at-point)
#+end_src

The details in =dired= create a lot of visual clutter and it's rarely needed, so we'll turn it off at the start. If required, it's easily accessible through ~(~.
#+begin_src emacs-lisp
(after! dired
  (add-hook 'dired-mode-hook #'dired-hide-details-mode))
#+end_src

Add useless directories/files to =dired-omit-files= to reduce visual clutter in project listings.
#+begin_src emacs-lisp
(after! dired
  (require 'rx)
  (setq dired-omit-files
        (rx (seq bol
                 (or "."
                     ".."
                     ".git"
                     "__pycache__"
                     ".pytest_cache")
                 eol))))
#+end_src

* Force-quit
Sometimes you just hafta gently nudge emacs to commit sudoku with a =kill -9=.
#+begin_src emacs-lisp
(defun +force-kill-emacs ()
  "Force-kill emacs - for when nothing else works."
  (interactive)
  (shell-command (format "kill -9 %s" (emacs-pid))))

(map! :leader "q F" #'+force-kill-emacs)
#+end_src

* Shell/Terminal
** vterm
The default scrollback size of 1000 is really small and takes away the advantages of having a searchable history. We'll turn it waaay up.
#+begin_src emacs-lisp
(after! vterm
  (setq vterm-max-scrollback 50000))
#+end_src

A lot of the terminal programs I use have vim bindings, so it becomes a major hassle to escape /evil/'s normal mode to use the program's normal mode. Moving the cursor is never trustworthy since it might just have moved for emacs and not for the underlying program. At the same time, disabling evil-mode in those buffers is not a great solution since then I don't access to any command (unless I map those in). =evil-emacs-state= provides a good compromise between the two by accessing leader keys through the alt leader (~C-SPC~ for me).
We'll enable this whenever we enter a terminal buffer so that it always does the /right thing/ (TM).
#+begin_src emacs-lisp
(after! (evil vterm)
  (evil-set-initial-state 'vterm-mode 'emacs))
#+end_src

* Projectile
** Running make
Surprisingly, Doom provides =+make/run= and =+make/run-last= to run make commands in a project (no more switching to the right directory), but does not bind them to any keys. Well, the ~<leader> p~ prefix is right there, and ~m~ isn't bound to anything (atleast right now).
#+begin_src emacs-lisp
(when (featurep! :tools make)
  (map! :leader
        "p m" #'+make/run
        "p M" #'+make/run-last))
#+end_src

** Project search
Provided through ~SPC /~ and ~SPC s p~, but for some reason I never remember those.
#+begin_src emacs-lisp
(map! :leader
      "p /" #'+default/project-search)
#+end_src

* Text zoom
#+begin_src emacs-lisp
(when (featurep! :ui hydra)
  (map! :leader
        (:prefix ("z" . "zoom")
         :desc "text-zoom" "f" #'+hydra/text-zoom/body)))
#+end_src

* Folding
The usual folding methods provided with Doom are sometimes not enough - I noticed this with Elixir.
=yafolding= seems like it's the solution here (it worked with Elixir, at least).

The Doom module which controls folding is =:editor fold=. Instead of changing this function and losing out on potential updates down the line, we can use a flimsy band-aid and override the keys in =yafolding-mode=.

#+begin_src emacs-lisp
(after! yafolding
  (map! :map yafolding-mode-map
        :n "zc" #'yafolding-hide-element
        :n "zo" #'yafolding-show-element
        :n "za" #'yafolding-toggle-element
        :n "zC" #'yafolding-hide-all
        :n "zO" #'yafolding-show-all
        :n "zA" #'yafolding-toggle-all))
#+end_src

* Autocompletion
In =mixed-pitch-mode= the completions have screwed-up alignment. We fix this by making them fixed-pitch.
#+begin_src emacs-lisp
(after! (company mixed-pitch)
  (let* ((company-prefixes '("company-preview-" "company-tooltip-")) ;; these are the only prefixes we care about
         (company-face-p (lambda (face)
                           (-any (lambda (prefix) (s-starts-with-p prefix (symbol-name face)))
                                 company-prefixes)))
         (company-faces (-filter company-face-p (face-list))))
    (setq mixed-pitch-fixed-pitch-faces (append mixed-pitch-fixed-pitch-faces company-faces))))
#+end_src

* Stop doom auto-starting modes
Doom adds a bunch of hooks for each module in =init.el=, which I then keep turning off each time I open a new buffer.
#+begin_src emacs-lisp
(remove-hook! '(prog-mode-hook text-mode-hook conf-mode-hook) #'highlight-indent-guides-mode)
(remove-hook! '(text-mode-hook) #'spell-fu-mode)
#+end_src

* Less useful, but *fancy*, features
** Screenshot code
Doesn't provide autoloading itself, so we load on calling the commands.
#+begin_src emacs-lisp
(use-package! escr
  :commands (escr-region-screenshot
             escr-frame-screenshot
             escr-window-screenshot)
  :init
  (setq escr-screenshot-directory (expand-file-name "~/pictures/scrots")
        escr-screenshot-format "code-%Y-%m-%d-%H.%M.%S.png"))
#+end_src
